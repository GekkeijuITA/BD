\documentclass[12pt, a4paper]{report}
\usepackage[utf8]{inputenc}
\input{Appunti Latex/variables.tex}
\preamble

\begin{document}
    \begin{titlepage}
        \centering
        \vfill
        {\bfseries\Huge
            Appunti Basi di Dati\\
            \vskip1cm
            \Large
            Lorenzo Vaccarecci\\
            \vskip1cm
            \normalsize
            A.A. 2023/2024
        }
        \vfill
        \includegraphics[width=10cm]{Appunti Latex/Immagini/logoUnige.png}
        \vfill
        \vfill
    \end{titlepage}
    \tableofcontents
    \chapter{Modello Relazionale}
        \section{Introduzione}
            Le interrogazioni sulle relazioni possono essere espresse in due formalismi:
            \begin{itemize}
                \item \textbf{Algebra relazionale}: le interrogazioni vengono espresse usando operatori specifici alle relazioni.
                \item \textbf{Calcolo relazionale}: le interrogazioni vengono espresse usando formule logiche.
            \end{itemize}
        \section{Relazioni}
            Un dominio è un insieme (anche infinito) di valori. Indicheremo con $\mathcal{D}$ l'insieme di tutti i domini.
            \subsection{Definizione: Prodotto cartesiano}
                Siano $D_{1},D_{2},\ldots,D_{k} \in \mathcal{D} \text{ con } k$ domini. Il prodotto cartesiano indicato con $D_{1}\times D_{2}\times \ldots \times D_{k}$, è definito come l'insieme $\left\{\left(v_{1},v_{2},\ldots,v_{k}\right)|v_{1}\in D_{1},\ldots,v_{k}\in D_{k}\right\}$.\\
                Gli elementi appartenenti al prodotto cartesiano sono detti \important{tuple}. Il prodotto cartesiano ha \textbf{grado} $k$.
            \subsection{Definizione: Relazione}
                Una relazione di $k$ domini è un sottoinsieme finito del prodotto cartesiano, ha \textbf{grado} $k$ quindi ogni tupla ha $k$ componenti. La \textbf{cardinalità} di una relazione è il numero di tuple appartenenti alla relazione. Una relazione è \underline{sempre} un insieme finito. \remark{Non vi sono tuple duplicate}.\\
            La coppia (nome di attributo, dominio) è detta \important{attributo}. L'uso di attributi permette di denotare le componenti di ogni tupla per nome piuttosto che per posizione.
            \subsection{Definizione: Schema di relazione}
                \begin{itemize}
                    \item $R$ un nome di relazione
                    \item $\left\{A_{1},A_{2},\ldots,A_{n}\right\}$ un insieme di nomi di attributi
                    \item $dom:\left\{A_{1},A_{2},\ldots,A_{n}\right\}\rightarrow \mathcal{D}$ una funzione totale che associa ad ogni nome di attributo il corrispondente dominio.
                \end{itemize}
                La coppia $(R(A_{1},A_{2},\ldots,A_{n}),dom)$ è uno schema di relazione. $U_{r}$ denota l'insieme dei nomi di attributi di $R$, ovvero \important{$U_{r}=\left\{A_{1},A_{2},\ldots,A_{n}\right\}$}.
            \subsection{Definizione: Schema di base di dati}
                Siano $S_{1},S_{2},\ldots,S_{n}$ schemi di relazioni distinti, $\mathcal{S}=\left\{S_{1},S_{2},\ldots,S_{n}\right\}$ è detto schema di base di dati.
            \subsection{Definizione: Tuple e relazione}
                Una tupla $t$ definita su una relazione $R$ è un insieme di funzioni totali che associano all'attributo di nome $A_{i}$ un valore del dominio di tale attributo. Una relazione definita su uno schema di relazione è un insieme finito di tuple definite su tale schema. Tale relazione è anche detta istanza dello schema. $t=\left[A_{1}:v_{1},A_{2}:v_{2},\ldots,A_{n}:v_{n}\right]$ dove $v_{i}\in dom(A_{i}) \text{ con } i=1,\ldots,n$. Notazione: $t[A_{i}]$ indica il valore dell'attributo $A_{i}$(quindi $v_{i}$) nella tupla $t$.
        \section{Valori nulli}
            Un aspetto importante nella modellazione dei dati riguarda il fatto che non sempre sono disponibili tutte le informazioni sulle entità del dominio applicativo che vengono rappresentate nella base di dati. L'approccio adottato è quello di introdurre un valore speciale, detto \important{valore nullo}, il quale denota la mancanza di un valore.\\
            Nella trattazione assumiamo di denotare il valore nullo con il simbolo '\texttt{?}'. Il valore nullo è un valore accettato in tutti i domini.
        \section{Chiavi}
            Una \important{chiave} di una relazione è un insieme di attributi che distingue fra loro le tuple della relazione. Più formalmente:
            \subsection{Definizione: Chiave e super-chiave}
                Sia $R$ uno schema di relazione. Un insieme $X\subseteq U_{R}$ di attributi di $R$ è chiave di $R$ se verifica le seguenti proprietà:
                \begin{enumerate}
                    \item \important{Univocità}: nella relazione non ci possono essere due tuple distinte che abbiano lo stesso valore per tutti gli attributi della chiave $X$.
                    \item Nessun \textbf{sottoinsieme proprio} di $X$ verifica la proprietà (1).
                \end{enumerate}
                Un insieme di attributi che verifica la proprietà (1) ma non la (2) è detto \important{super-chiave} di $R$. Una super-chiave può essere una chiave della relazione.\\
                In una relazione ci possono essere più insiemi di attributi che soddisfano le due proprietà. In tal caso si parla di \important{chiavi candidate}. \textbf{Una relazione ha sicuramente almeno una chiave (sia primaria che super)}. Nel caso in cui ci sono più chiavi candidate, una di queste viene scelta come \important{chiave primaria} su cui il DBMS ottimizza le operazioni.\\
                Un criterio per scegliere la chiave primaria è quello di scegliere la chiave più piccola in termini di numero di attributi o quella più usata nelle interrogazioni. Una chiave non può contenere valori nulli.
            \subsection{Definizione: Chiave esterna}
                Sia $R_{1}$ ed $R_{2}$ due relazioni, sia $X$ una chiave per $R_{1}$ e $Y$ una chiave per $R_{2}$ tale che $Y$ e $X$ contengano lo stesso numero di attributi e di dominio compatibile (\textit{es. interi e reali sono compatibili}). $X$ è una chiave esterna di $R_{1}$ su $R_{2}$ se per ogni tupla $t$ di $R_{1}$ esiste una tupla $t'$ di $R_{2}$ tale che $t[X]=t'[Y]$. $R_{1}$ viene detta relazione \textbf{referente} e $R_{2}$ relazione \textbf{riferita}.\\
                \remark{Vincolo di integrità refernziale}: se una tupla $t$ di $R_{1}$ fa riferimento ai valori della chiave di una tupla $t'$ di $R_{2}$, allora $t'$ deve esistere in $R_{2}$. Può essere violata da inserimenti e modifiche nella relazione referente e da cancellazioni e modifiche nella relazione riferita.\\
                Una relazione può contenere più chiavi esterne, eventualmente anche sulla stessa relazione e possono assumere valori nulli.\\
                \textbf{Notazione:}
                \begin{equation*}
                    R_{1}\left(\dots,chiave\_esterna^{R_{2}},\dots\right)
                \end{equation*}
    \chapter{Modello ER}
    \section{Introduzione}
    Il termine \important{diagramma ER} indica la rappresentazione grafica di uno schema concettuale ER.
    Gli elementi principali di un diagramma ER sono:
    \begin{itemize}
        \item \important{Entità}: una collezione di oggetti della realtà che vogliamo modellare che possiedono caratteristiche comuni, graficamente viene rappresentata da un rettangolo
        \item \important{Relazioni} (o associazione): rappresenta un legame logico tra più entità, graficamente viene rappresentata da un rombo
        \item \important{Attributi}: rappresenta una proprietà posseduta da un'entità o da una relazione, è \remark{mono-valore} se può assumere al più un valore (\textit{es. la matricola di uno studente}), è \remark{multi-valore} altrimenti (\textit{es. i numeri di telefono di un'azienda}). Può essere a sua volta essere formato da \textit{sotto-attributi} rendendolo \remark{composto}, un attributo composto può avere domini di diverso tipo (\remark{domini composti})
    \end{itemize}
    \begin{center}
        \begin{tikzpicture}[node distance=4.7em]
            \node[entity] (entity1) {$E_{1}$};
            \node (attr1) [above of = entity1] {A};
            \draw (entity1) -- node[near end, above, draw, circle, minimum size=0.01cm, fill=white] {} (attr1);
            \node[relationship] (rel1) [right of = entity1] {R} edge (entity1);
            \node[entity] (entity2) [right of = rel1] {$E_{2}$} edge (rel1);
            \node[attribute] (attr2) [above of = entity2] {B} edge (entity2);
            \node (attr3) [above of = attr2] {C} edge (attr2);
            \draw (attr2) -- node[near end, above, draw, circle, minimum size=0.01cm, fill=white] {} (attr3);
            \node (attr4) [above left of = attr2] {D} edge (attr2);
            \draw (attr2) -- node[near end, above left, draw, circle, minimum size=0.01cm, fill=white] {} (attr4);
            \node (attr5) [above right of = attr2] {E} edge (attr2);
            \draw (attr2) -- node[near end, above right, draw, circle, minimum size=0.01cm, fill=white] {} (attr5);
        \end{tikzpicture}
    \end{center}
    Le istanze di un'associazione sono un sottoinsieme del prodotto cartesiano delle entità coinvolte, non possono esistere duplicati. Le associazioni sono classificate in base al loro \remark{grado} (il numero di entità in relazione):
    \begin{itemize}
        \item \textbf{Unaria}: un'entità è in relazione con se stessa
        \item \textbf{Binaria}: due entità sono in relazione
        \item \textbf{$n$-aria}: $n$ entità sono in relazione
    \end{itemize}
    Le informazioni sui domini degli attributi non sono direttamente rappresentabili in un diagramma ER, ma possono essere specificate nella documentazione a corredo dei diagrammi ER.
    \section{Vincoli di integrità}
    \subsection{Vincoli di cardinalità}
    I vincoli di cardinalità per associazioni stabiliscono il numero minimo e massimo di istanze di un'associazione a cui le istanze delle entità coinvolte nella associazione possono partecipare. Graficamente, vengono rappresentati come coppia di valori interi $(min,max)$ collocata vicino alla linea che connette l'associazione con ciascuna entità che mette in relazione.
    \begin{center}
        \begin{tikzpicture}[node distance=10em]
            \node[entity] (entity1) {$E_{1}$};
            \node[relationship] (rel1) [right of = entity1] {R};
            \node[entity] (entity2) [right of = rel1] {$E_{2}$};
            \path (entity1) edge node[above]{$(min,max)$} (rel1);
            \path (rel1) edge node[above]{$(min,max)$} (entity2);
        \end{tikzpicture}
    \end{center}
    $(min,max)$:
    \begin{itemize}
        \item $min=0$: l'entità non è obbligata a partecipare all'associazione
        \item $min=1$: l'entità è obbligata a partecipare all'associazione
        \item $max=1$: l'entità può partecipare al massimo una volta all'associazione
        \item $max=n$: l'entità può partecipare al massimo $n$ volte all'associazione
    \end{itemize}
    Se in un diagramma ER non è specificata la cardinalità di un'associazione, si assume che il vincolo sia $(0,n)$.\\
    Date due entità $E_{1}$ e $E_{2}$ se:
    \begin{itemize}
        \item $max_{E_{1}}=max_{E_{2}}=1$ allora l'associazione è \remark{uno a uno}
        \item $max_{E_{1}}=1,max_{E_{2}}=n$ allora l'associazione è \remark{uno a molti}
        \item $max_{E_{1}}=max_{E_{2}}=n$ allora l'associazione è \remark{molti a molti}
    \end{itemize}
    Le cardinalità possono essere specificate anche per gli attributi, permettendo di specificare se un attributo è mono o multi-valore, e se è obbligatorio o meno. Se non viene specificata la cardinalità di un attributo, si assume che sia $(1,1)$.
    \subsection{Vincoli di identificazione}
    Definire un vincolo d'identificazione per un'entità significa specificare un insieme di attributi e/o entità che posseggono la proprietà di identificare univocamente le istanze dell'entità (\important{identificatori o chaivi}).
    \begin{itemize}
        \item \important{Identificatore interno}: è costituito da uno o più attributi dell'entità stessa
        \item \important{Identificatore misto}: è costituito da attributi dell'entità e da attributi di altre entità
        \item \important{Identificatore esterno}: è costituito da attributi di altre entità
        \item \important{Identificatore semplice}: è costituito da un solo attributo
        \item \important{Identificatore composto}: è costituito da più attributi
    \end{itemize}
    Un'entità le cui istanze vengono identificate mediante l'associazione con altre entità viene chiamata \remark{entità debole}.
    \section{Gerarchie di generalizzazione}
    Nel modello ER è possibile organizzare le entità in gerarchia di generalizzazione definendo un insieme di entità dette \remark{figlie} come specializzazione di un'altra entità detta \remark{padre} rappresentante le proprietà in comune a tutte le entità figlie.
    \begin{itemize}
        \item \important{Generalizzazione totale}: ogni istanza dell'entità padre è anche un'istanza di \textbf{almeno} una delle entità figlie
        \item \important{Generalizzazione parziale}: se un'istanza dell'entità padre non è un'istanza di nessuna delle entità figlie
        \item \important{Generalizzazione esclusiva}: se un'istanza dell'entità padre è un'istanza di \textbf{al più} una delle entità figlie
        \item \important{Generalizzazione condivise}: se un'istanza dell'entità padre può essere un'istanza di \textbf{più} entità figlie
    \end{itemize}
    Le generalizzazioni possono essere di quattro tipi diversi: totali esclusive, totali condivise, parziali esclusive e parziali condivise.
    \chapter{Progettazione Logica}
    \section{Introduzione}
    L'obiettivo principale della progettazione logica è tradurre uno schema ER in uno schema relazionale equivalente. Si articola in due fasi:
    \begin{itemize}
        \item \remark{Fase di ristrutturazione dello schema ER}: questa fase prevede l'eliminazione dallo schema ER di tutti quei costrutti non direttamente rappresentabili nel modello relazionale, anche questa fase si può suddividere in più sotto-fasi:
        \begin{itemize}
            \item analisi della ridondanza
            \item partizionamento/accorpamento di entità
            \item eliminazione degli attributi composti e multi-valore
            \item eliminazione delle gerarchie di generalizzazione
        \end{itemize}
        \item \remark{Fase di traduzione dello schema ER}: in questa fase, lo schema ER restituito dalla fase di ristrutturazione viene tradotto in un equivalente schema relazionale. \underline{La traduzione non è sempre univoca}.
    \end{itemize}
    \section{Fase di ristrutturazione}
    \subsection{Analisi della ridondanza}
    Uno schema ER presenta delle ridondanze quando un'informazione viene rappresentata sia esplicitamente nello schema sia può essere derivata da altre informazioni presenti nello schema. Nei diagrammi ER la presenza di ridondanza dovrebbe essere limitata solo a quei casi in cui sia possibile ottenere un significativo beneficio in termini di tempo di esecuzione delle interrogazioni.
    \subsection{Partizionamento/accorpamento di entità}
    Lo schema ER può essere ulteriormente ristrutturato partizionando od accorpando entità ed associazioni sulla base dell'analisi del carico di lavoro. Un'entità $E$ può essere partizionata in due entità $E_{1},E_{2}$ una delle quali identificata esternamente dall'altra, collegate mediante un'associazione uno a uno. Questa operazione può essere conveniente quando alcune operazioni frequenti coinvolgono solo un sottoinsieme degli attributi di $E$. Viceversa, due entità $E_{1},E_{2}$ collegate da un'associazione uno a uno, possono essere accorpate in un'unica entità contenente gli attributi di $E_{1}$ e $E_{2}$ nel caso in cui operazioni frequenti abbiano la necessità di accedere ad entrambi gli insiemi di attributi.
    \subsection{Eliminazione degli attributi composti e multi-valore}
    Il modello relazionale consente la specifica solo di attributi semplici e mono-valore. E' quindi necessario ristrutturare lo schema ER generato dalla fase di progettazione concettuale per eliminare eventuali attributi composti e multi-valore in esso presenti. L'eliminazione di un attributo composto $A$ da un'entità $E$ può avvenite in due modi:
    \begin{itemize}
        \item \remark{Eliminando i sotto-attributi di $A$ e considerando l'attributo composto come un attributo semplice}
        \item \remark{Considerando tutti i sotto-attributi di $A$ come attributi di $E$}
    \end{itemize}
    Quest'ultima soluzione richiede ovviamente una ridefinizione del dominio dell'attributo.\\
    La modellazione di attributi multi-valore mediante attributi a valore semplice richiede la definizione di una nuova entità, collegata all'entità di partenza tramite un'opportuna associazione, in cui l'attributo multi-valore è rappresentato mediante un attributo mono-valore che identifica l'entità. Il vincolo di cardinalità dell'associazione è quello dell'attributo multi-valore oggetto di ristrutturazione.
    \subsection{Eliminazione delle gerarchie di generalizzazione}
    Consideriamo un'entità $E$ generalizzazione di un insieme di entità $E_{1},\ldots,E_{n}$
    \begin{itemize}
        \item \important{Eliminazione delle entità figlie}: Le entità figlie vengono eliminate ed i loro attributi vengono inseriti nell'entità padre come attributi opzionali. \begin{itemize}
            \item \remark{Generalizzazione totale}: l'attributo portato al padre non può essere nullo
            \item \remark{Generalizzazione parziale}: un valore nullo indica un'istanza dell'entità padre che non era istanza di alcuna delle entità figlie
            \item \remark{Generalizzazione condivise}: l'attributo sarà multi-valore in quanto un'istanza dell'entità padre potrebbe essere istanza di più entità figlie
        \end{itemize}
        \item \important{Eliminazione dell'entità padre}: consiste nell'eliminare l'entità padre $E$ e nell'inserire i suoi attributi in ciascuna delle entità figlie. Tale procedimento è applicabile solo nel caso in cui la generalizzazione sia \textbf{totale}. \begin{itemize}
            \item \remark{Generalizzazione esclusiva}: è necessario aggiungere un vincolo per indicare che non possono esistere istanze di due entità figlie distinte aventi lo stesso valore per gli identificatori.
        \end{itemize}
        Ogni associazione a cui partecipava l'entità padre l'entità padre viene inoltre sostituita con $n$ nuove associazioni, una per ogni entità figlia.
        \item \important{Sostituzione della generalizzazione con associazioni}: le entità coinvolte nella generalizzazione non vengono modificate, mentre la gerarchia di generalizzazione viene sostituita da $n$ associazioni uno a uno, ognuna delle quali lega l'entità padre con una diversa entità figlia. Le entità figlie sono identificate esternamente dall'entità padre e partecipano obbligatoriamente alle associazioni create mentre la partecipazione dell'entità padre è opzionale. \begin{itemize}
            \item \remark{Generalizzazione esclusiva}: un'istanza del padre non può partecipare contemporaneamente a due o più associazioni
            \item \remark{Generalizzazione totale}: ogni istanza dell'entità padre deve partecipare obbligatoriamente ad almeno un'associazione
        \end{itemize}
    \end{itemize}
    In generale, la scelta di accorpare le entità figlie nell'entità padre comporta uno spreco di memoria per la presenza dei valori nulli. La soluzione di eliminare l'entità padre consente un risparmio di memoria rispetto alla soluzione di eliminare le entità figlie in quanto evita il problema dei valori nulli.
    \section{Fase di traduzione}
    La fase di traduzione può essere suddivisa nelle seguenti sotto-fasi:
    \begin{itemize}
        \item \remark{Traduzione delle entità}
        \item \remark{Traduzione delle associazioni}
        \item \remark{Traduzione dei vincoli di integrità}
        \item \remark{Ottimizzazioni finali}
    \end{itemize}
    \subsection{Traduzione delle entità}
    \begin{center}
        \begin{tikzpicture}[node distance=4.7em]
            \node[entity] (entity) {$E$};
            \node (attr1) [above of = entity] {A} edge (entity);
            \node (attr2) [above left of = entity] {B} edge (entity);
            \node (attr3) [above right of = entity] {C} edge (entity);
            \draw (entity) -- node[near end, above, draw, circle, minimum size=0.01cm, fill=white] {} (attr1);
            \draw (entity) -- node[near end, above left, draw, circle, minimum size=0.01cm, fill=black] {} (attr2);
            \draw (entity) -- node[near end, above right, draw, circle, minimum size=0.01cm, fill=white] {} (attr3);
        \end{tikzpicture} 
        $\rightarrow$
        E(\underline{B},A,C);
    \end{center}
    Nel caso di chiavi esterne si scrivono in fondo (di solito) e in corsivo indicando anche la tabella di provenienza per una maggiore comprensione della traduzione: E(\underline{K},...,\textit{$FK^{E_{i}}$}).\\
    I criteri per la scelta della chiave primaria si possono sintetizzare come segue:
    \begin{itemize}
        \item \important{Non devono contenere valori nulli}
        \item \important{Devono essere composti da pochi attributi}
        \item \important{Sono gli attributi più utilizzati nelle interrogazioni per accedere alle entità}
    \end{itemize}
    \subsection{Traduzione delle associazioni}
    \begin{center}
        \begin{tikzpicture}[node distance=10em, auto]
            \node[entity] (entity) {$E_{1}$};
            \node[relationship] (rel) [right of = entity] {R} edge (entity);
            \node[entity] (entity2) [right of = rel] {$E_{2}$} edge (rel);
            \path (entity1) edge node[above]{$(min_{1},max_{1})$} (rel1);
            \path (rel1) edge node[above]{$(min_{2},max_{2})$} (entity2);
        \end{tikzpicture}
    \end{center}
    \textit{Consideriamo che $E_{1}$ ha gli attributi A,B e $E_{2}$ ha gli attributi C,D. La chiave di $E_{1}$ è K e la chiave di $E_{2}$ è L.}\\
    Casi:
    \begin{itemize}
        \item \important{Associazione uno a uno}: si "elimina" una delle due entità e si accorpa con l'altra: $E_{1}(\underline{K,L},A,B,C,D)$
        \item \important{Associazione uno a molti}: l'entità "da sola" riceve la chiave dell'altra entità come chiave esterna: $E_{1}(\underline{K},A,B,L),E_{2}(\underline{L},C,D, K^{E_{1}})$
        \item \important{Associazione molti a molti}: si crea una nuova relazione con le chiavi delle entità coinvole e gli eventuali attributi dell'associazione: $R(\underline{K,L})$
    \end{itemize}
    \chapter{Algebra Relazionale}
    \section{Introduzione}
    L'algebra è composta da cinque operazioni di base:
    \begin{itemize}
        \item Proiezione
        \item Selezione
        \item Prodotto cartesiano
        \item Unione
        \item Differenza
    \end{itemize}
    Ogni operazione ha come argomento una o due relazioni e restituisce come risultato una relazione; è pertanto possibile applicate un'operazione al risultato di un'altra operazione (proprietà di chiusura). In riferimento alla notazione per nome, viene introdotta un'ulteriore operazione, di \textbf{ridenominazione}, che permette di modificare i nomi degli attributi.
    \section{Ridenominazione}
    La ridenominazione di una relazione $R$ indicata con
    \begin{equation*}
        \rho_{A_{1},A_{2},\ldots,A_{n} \leftarrow B_{1},B_{2},\ldots,B_{n}}(R)
    \end{equation*}
    ridenomina l'attributo di nome $A_{i}$ con il nome $B_{i}, i=1,\ldots,n$. La ridenominazione è corretta se il nuovo schema di relazione per $R$ ha attributi con nomi tutti distinti. 
    \section{Proiezione}
    La proiezione di una relazione $R$ su un insieme $A={A_{1},A_{2},\ldots,A_{n}}\subseteq U_{R}$ di nomi di attributi di $R$, indicata con:
    \begin{equation*}
        \Pi_{A_{1},A_{2},\ldots,A_{n}}(R)
    \end{equation*}
    è una relazione di grado $n$ le cui tuple hanno come attributi solo gli attributi specificati in $A$. Il risultato della proiezione è un insieme di tuple senza duplicati.
    \section{Selezione}
    La selezione su una relazione $R$, dato un predicato $F$ su $R$, indicata con:
    \begin{equation*}
        \sigma_{F}(R)
    \end{equation*}
    genera una relazione che contiene tutte le tuple di $R$ che verificano $F$. $F$ può essere una combinazione degli operatori booleani $\land,\lor, \lnot$ e operatori relazionali di confronto $=,\neq,<,>,\leq,\geq$.\\
    Lo schema (ed il grado) della relazione risultato sono uguali a quelli rella relazione operando.
    \section{Prodotto cartesiano}
    Il prodotto cartesiano di due relazioni $R$ e $S$, indicato con:
    \begin{equation*}
        R \times S
    \end{equation*}
    sono tutte le possibili combinazione delle tuple di $R$ con le tuple di $S$. La relazione risultato ha grado pari alla somma dei gradi delle relazioni operandi e la cardinalità è il prodotto delle cardinalità degli argomenti.\\
    \textbf{Il prodotto cartesiano può essere applicato solo se le due relazioni $R$ e $S$ hanno schemi disgiunti}.
    \section{Unione}
    l'unione delle relazioni $R$ ed $S$, indicata con:
    \begin{equation*}
        R \cup S
    \end{equation*}
    è l'insieme delle tuple che sono in $R$ od in $S$. \textbf{Le due relazioni devono avere lo stesso schema}.\\
    Le tuple duplicate vengono eliminate dal risultato.
    \section{Differenza}
    La differenza delle relazioni $R$ ed $S$, indicata con:
    \begin{equation*}
        R - S
    \end{equation*}
    è l'insieme delle tuple che sono in $R$ ma non in $S$. \textbf{Le due relazioni devono avere lo stesso schema e stesso grado}.
    \section{Intersezione}
    L'intersezione delle relazioni $R$ ed $S$, indicata con:
    \begin{equation*}
        R \cap S = R - (R - S)
    \end{equation*}
    restituisce le tuple che sono sia in $R$ che in $S$. \textbf{Le due relazioni devono avere lo stesso schema}.
    \section{Join}
    Il join (detto anche theta-join) di due relazioni $R$ ed $S$ sugli attributi $A$ di $R$ e $B$ di $S$, indicato con:
    \begin{equation*}
        R \bowtie_{A\theta B} S
    \end{equation*}
    dove $\theta$ è un operatore relazionale di confronto, è definito dall'espressione algebrica:
    \begin{equation*}
        \sigma_{A\theta B}(R \times S)
    \end{equation*}
    il join pertanto è un prodotto cartesiano seguito da una selezione. \\
    \textbf{Il join può essere applicato solo se le due relazioni $R$ ed $S$ hanno schemi disgiunti}.
    \textit{Il join si chiama equi-join se l'operatore $\theta$ è l'uguaglianza.}
    \subsection{Join naturale}
    \begin{equation*}
        R \bowtie S
    \end{equation*}
    è un join in cui si considerano solo gli attributi comuni tra $R$ ed $S$ e poi elimina i duplicati dalla relazione risultato. Nel caso particolare $U_{R}=U_{S}$, il join naturale degenera nell'intersezione, mentre, nel caso $U_{R}\cap U_{S}=\emptyset$, degenera nel prodotto cartesiano.
    \section{Divisione}
    L'operazione di divisione, date due relazioni $R$ ed $S$, con insiemi di attributi $U_{R}\subset U_{S}$ indicata con:
    \begin{equation*}
        R \div S
    \end{equation*}
    \remark{L'idea intuitiva è che l'operazione di divisione è utile per determinare le tuple per cui in una relazione c'è una corrispondenza con tutte le tuple di un'altra relazione}. Il grado della relazione risultato è $h-k$ dove $h$ è il grado di $R$ e $k$ è il grado di $S$.\\
    La divisione è \textbf{commutaiva} e \textbf{associativa}.
    La divisione è un'operazione derivata dall'algebra relazionale. La divisione di due relazioni $R$ ed $S$ è definita come:
    \begin{equation*}
        R \div S = \Pi_{D}(R) - \Pi_{D}((\Pi_{D}(R)\times S)-R)
    \end{equation*}
    \chapter{Linguaggio SQL}
    \section{Tipi}
    \begin{itemize}
        \item \texttt{INTEGER}: interi a 32 bit
        \item \texttt{SMALLINT}: interi a 16 bit
        \item \texttt{BIGINT}: interi a 64 bit
        \item \texttt{NUMERIC}: numeri decimali, usa due parametri: la precisione (il numero totale di cifre) e la scala (il numero di cifre dopo la virgola) $\rightarrow$ \texttt{NUMERIC(precisione,scala)} i valori di default sono 1 (precisione) e 0 (scala)
        \item \texttt{DECIMAL}: come \texttt{NUMERIC} ma le cifre possono essere $\geq$ p
        \item \texttt{REAL}: numeri in virgola mobile a precisione singola
        \item \texttt{DOUBLE PRECISION}: numeri in virgola mobile a precisione doppia
        \item \texttt{FLOAT}: numeri in virgola mobile a precisione personalizzata $\rightarrow$ \texttt{FLOAT(p)} con $1\leq p \leq n$ dove $n$ dipende dall'implementazione
        \item \texttt{CHARACTER}: stringhe di lunghezza fissa $\rightarrow$ \texttt{CHARACTER(n)}, di default è 1
        \item \texttt{CHARACTER VARYING}: stringhe di lunghezza variabile $\rightarrow$ \texttt{CHARACTER VARYING(n)} dove $n$ è la lunghezza massima
        \item \texttt{DATE}: data in formato \texttt{YYYY-MM-DD}
        \item \texttt{TIME}: tempo in formato \texttt{HH:MM:SS}, può essere specificata la precisione dei secondi $\rightarrow$ \texttt{TIME(p)} con $0\leq p \leq 6$
        \item \texttt{TIMESTAMP}: concatenazione di \texttt{DATE} e \texttt{TIME}
        \item \texttt{INTERVAL}: durata temporale in riferimento ad uno o più dei qualificatori tra \texttt{YEAR}, \texttt{MONTH}, \texttt{DAY}, \texttt{HOUR}, \texttt{MINUTE}, \texttt{SECOND} $\rightarrow$ \texttt{INTERVAL 'valore' qualificatore}
        \item \texttt{BOOLEAN}: valore booleano \texttt{TRUE},\texttt{FALSE} o \texttt{UNKNOWN}
        \item \texttt{BLOB}: dati binari di lunghezza variabile
        \item \texttt{CLOB}: dati di testo di lunghezza variabile
    \end{itemize}
    \section{Creazione di tabelle}
    \begin{lstlisting}[language=SQL]
        CREATE TABLE nome_tabella(
            nome_colonna tipo_colonna,
            ...
        );
    \end{lstlisting}
    \subsection{Obbligatorietà di colonne}
    Per la specifica dell'obbligatorietà di una colonna si utilizza la clausola \texttt{NOT NULL}:
    \begin{lstlisting}[language=SQL]
        CREATE TABLE nome_tabella(
            nome_colonna tipo_colonna NOT NULL,
            ...
        );
    \end{lstlisting}
    \subsection{Chiavi}
    Per la specifica di una chiave primaria si utilizza la clausola \texttt{PRIMARY KEY}:
    \begin{lstlisting}[language=SQL]
        CREATE TABLE nome_tabella(
            nome_colonna tipo_colonna PRIMARY KEY,
            ...
        );
    \end{lstlisting}
    Per le chiavi alternative si usa \texttt{UNIQUE}. Se si hanno chiavi composte da più attributi:
    \begin{lstlisting}[language=SQL]
        CREATE TABLE nome_tabella(
            nome_colonna1 tipo_colonna,
            nome_colonna2 tipo_colonna,
            ...
            PRIMARY KEY(nome_colonna1,nome_colonna2)
        );
    \end{lstlisting}
    (stessa cosa per \texttt{UNIQUE}).\\
    Per la specifica di una chiave esterna si utilizza la clausola \texttt{FOREIGN KEY}:
    \begin{lstlisting}[language=SQL]
        CREATE TABLE nome_tabella(
            nome_colonna tipo_colonna,
            ...
            FOREIGN KEY(nome_colonna)
                REFERENCES nome_tabella_esterna(nome_colonna_esterna)
        );
    \end{lstlisting}
    La chiave esterna può avere delle "azioni" da eseguire in caso di cancellazione (\texttt{ON DELETE}):
    \begin{itemize}
        \item \texttt{NO ACTION}: la cancellazione di una tupla non è permessa se esistono riferimenti ad essa
        \item \texttt{CASCADE}: la cancellazione di una tupla comporta la cancellazione delle tuple che fanno riferimento ad essa
        \item \texttt{SET NULL}: la cancellazione di una tupla comporta l'impostazione a \texttt{NULL} del valore della chiave esterna delle tuple che fanno riferimento ad essa
        \item \texttt{SET DEFAULT}: la cancellazione di una tupla comporta l'impostazione al valore di default del valore della chiave esterna delle tuple che fanno riferimento ad essa
    \end{itemize}
    In caso di modifica (\texttt{ON UPDATE}) le "azioni" funzionano in modo simile.
    \section{Cancellazione di tabelle}
    \begin{lstlisting}[language=SQL]
        DROP TABLE nome_tabella [CASCADE | RESTRICT];
    \end{lstlisting}
    L'opzione \texttt{CASCADE} permette di eliminare anche le tabelle che fanno riferimento alla tabella da eliminare, mentre \texttt{RESTRICT} impedisce la cancellazione se esistono tabelle che fanno riferimento alla tabella da eliminare.
    \section{Modifica di tabelle}
    \subsection{Aggiunta di colonne}
    \begin{lstlisting}[language=SQL]
        ALTER TABLE nome_tabella
            ADD nome_colonna tipo_colonna;
    \end{lstlisting}
    \subsection{Modifica di colonne}
    \begin{lstlisting}[language=SQL]
        ALTER TABLE nome_tabella
            ALTER COLUMN nome_colonna SET DATA TYPE tipo_colonna;
    \end{lstlisting}
    \subsection{Cancellazione di colonne}
    \begin{lstlisting}[language=SQL]
        ALTER TABLE nome_tabella
            DROP COLUMN nome_colonna [CASCADE | RESTRICT];
    \end{lstlisting}
    \section{Interrogazioni}
    \subsection{Selezione}
    \begin{lstlisting}[language=SQL]
        SELECT [DISTINCT] lista_attributi
        FROM nome_tabella
        WHERE condizione;
    \end{lstlisting}
    La clausola \texttt{DISTINCT} permette di eliminare i duplicati.\\
    Nella selezione ci si può riferire alle colonne mettendo prima il nome della tabella a cui appartengono seguito da un punto:
    \begin{lstlisting}[language=SQL]
        SELECT nome_tabella.nome_colonna
        FROM nome_tabella;
    \end{lstlisting}
    Questo può aiutare in caso di colonne con lo stesso nome in tabelle diverse o semplicemente per una maggiore chiarezza.\\
    Se ci si vuole riferire a tutte le colonne di una (o più) tabelle si può usare il simbolo \texttt{*}:
    \begin{lstlisting}[language=SQL]
        SELECT *
        FROM nome_tabella;
    \end{lstlisting}
    Nel \texttt{WHERE} si possono usare i connettivi logici \texttt{AND}, \texttt{OR} e \texttt{NOT}.
    \subsection{Operatori di confronto}
    \subsubsection{Condizioni su intervalli di valori}
    L'operatore \texttt{BETWEEN} permette di ritrovare le tuple che contengono valori di una colonna in un intervallo specificato:
    \begin{lstlisting}[language=SQL]
        SELECT *
        FROM nome_tabella
        WHERE nome_colonna BETWEEN valore1 AND valore2;
    \end{lstlisting}
    \texttt{BETWEEN} è l'abbreviazione di:
    \begin{lstlisting}[language=SQL]
        SELECT *
        FROM nome_tabella
        WHERE nome_colonna >= valore1 AND nome_colonna <= valore2;
    \end{lstlisting}
    Può essere usato con il \texttt{NOT}.
    \subsubsection{Ricerca di valori in un insieme}
    L'operatore \texttt{IN} permette di determinare le tuple che contengono uno tra i valori di un insieme spiecificato:
    \begin{lstlisting}[language=SQL]
        SELECT *
        FROM nome_tabella
        WHERE nome_colonna IN (valore1,valore2,...);
    \end{lstlisting}
    E' l'abbreviazione di:
    \begin{lstlisting}[language=SQL]
        SELECT *
        FROM nome_tabella
        WHERE nome_colonna = valore1 OR nome_colonna = valore2 OR ...;
    \end{lstlisting}
    Può essere usato con il \texttt{NOT}.
    \subsubsection{Condizioni di confronto per stringhe di caratteri}
    L'operatore \texttt{LIKE} permette di eseguire alcune sepmlici operazioni di \textit{pattern matching} su colonne di tipo stringa:
    \begin{itemize}
        \item \texttt{\%}: rappresenta una sequenza di zero o più caratteri
        \item \texttt{\_}: rappresenta un singolo carattere
    \end{itemize}
    \begin{lstlisting}[language=SQL]
        SELECT *
        FROM nome_tabella
        WHERE nome_colonna LIKE '__d%';  -- trova la tupla che inizia con due caratteri qualsiasi, seguita da 'd' e poi da zero o piu' caratteri
    \end{lstlisting}
    \subsection{Espressioni e funzioni aritmetiche}
    \begin{itemize}
        \item \texttt{+}: somma
        \item \texttt{-}: sottrazione
        \item \texttt{*}: moltiplicazione
        \item \texttt{/}: divisione
        \item \texttt{ABS($n$)}: valore assoluto di $n$
        \item \texttt{MOD($n$,$m$)}: resto della divisione di $n$ per $m$
    \end{itemize}
    \subsection{Espressioni e funzioni per stringhe}
    \begin{itemize}
        \item \texttt{||}: concatenazione
        \item \texttt{LENGTH($s$)}: lunghezza della stringa $s$
        \item \texttt{LOWER($s$)}: trasforma la stringa $s$ in minuscolo
        \item \texttt{UPPER($s$)}: trasforma la stringa $s$ in maiuscolo
        \item \texttt{SUBSTR($s$,$m$,$n$)}: sottostringa di $s$ a partire dalla posizione $m$ di lunghezza $n$, se $n$ è omesso la sottostringa è fino alla fine di $s$
        \item \texttt{TRIM $s1$ FROM $s2$}: rimuove gli spazi bianchi da $s2$, se $s1$ è specificato rimuove i caratteri di $s1$ da $s2$
    \end{itemize}
    \subsection{Espressioni e funzioni per date e tempi}
    \begin{itemize}
        \item \texttt{CURRENT\_DATE}: data corrente
        \item \texttt{CURRENT\_TIME}: tempo corrente
        \item \texttt{CURRENT\_TIMESTAMP}: data e tempo correnti
        \item \texttt{EXTRACT($campo$ FROM $data$)}: estrae il campo specificato da una data o un tempo (\textit{es.} \texttt{EXTRACT(YEAR FROM CURRENT\_DATE)} restituisce l'anno corrente)
    \end{itemize}
    \subsection{Ordinamento dei risultati di una query}
    \begin{lstlisting}[language=SQL]
        SELECT *
        FROM nome_tabella
        ORDER BY nome_colonna [ASC | DESC];
    \end{lstlisting}
    Ordina i risultati in base ai valori della colonna specificata in ordine crescente (\texttt{ASC}) o decrescente (\texttt{DESC}).
    \subsection{Operazione di join}
    \begin{itemize}
        \item \texttt{CROSS JOIN}: prodotto cartesiano tra due tabelle \begin{lstlisting}[language=SQL]
            SELECT *
            FROM tabella1
            CROSS JOIN tabella2;
        \end{lstlisting}
        \item \texttt{JOIN ON}: prodotto cartesiano tra due tabelle con una condizione \begin{lstlisting}[language=SQL]
            SELECT *
            FROM tabella1
            JOIN tabella2
            ON tabella1.colonna = tabella2.colonna;
        \end{lstlisting}
        \item \texttt{JOIN USING}: prodotto cartesiano tra due tabelle con una condizione su una o piu' colonne comuni \begin{lstlisting}[language=SQL]
            SELECT *
            FROM tabella1
            JOIN tabella2
            USING (colonna_comune1, ...);
        \end{lstlisting}
        \item \texttt{NATURAL JOIN}: prodotto cartesiano tra due tabelle con una condizione su tutte le colonne con lo stesso nome \begin{lstlisting}[language=SQL]
            SELECT *
            FROM tabella1
            NATURAL JOIN tabella2;
        \end{lstlisting}
    \end{itemize}
    \subsubsection{Outer join}
    Con i \texttt{JOIN} non si ha traccia delle tuple di una tabella che corrispondono a nessuna tupla dell'altra tabella. Per ovviare a questo problema si usano le \texttt{OUTER JOIN} che aggiunge al risultato anche le tuple che non hanno corrispondenza completandole con valori nulli. Il \texttt{JOIN} originario è detto \texttt{INNER JOIN}.
    \begin{itemize}
        \item \texttt{FULL}: tutte le tuple di entrambe le tabelle che non hanno corrispondenza vengono completate ed inserite nel risultato
        \item \texttt{LEFT}: solo le tuple della tabella a sinistra che non hanno corrispondenza vengono completate ed inserite nel risultato
        \item \texttt{RIGHT}: solo le tuple della tabella a destra che non hanno corrispondenza vengono completate ed inserite nel risultato
    \end{itemize}
    \subsection{Funzioni di gruppo}
    \begin{itemize}
        \item \texttt{MAX}: massimo valore di un insieme di valori
        \item \texttt{MIN}: minimo valore di un insieme di valori
        \item \texttt{SUM}: somma di un insieme di valori
        \item \texttt{AVG}: media di un insieme di valori
        \item \texttt{COUNT}: cardinalità di un insieme
    \end{itemize}
    Esistono anche le funzioni \texttt{STDEV} e \texttt{VAR} per calcolare la deviazione standard e la varianza.\\
    La funzione \texttt{COUNT} puà avere tre tipi di argomenti:
    \begin{itemize}
        \item un nome di una colonna: conta il numero di valori non nulli nella colonna specificata
        \item un nome di colonna preceduto dal qualificatore \texttt{DISTINCT}: conta il numero di valori distinti non nulli nella colonna specificata
        \item \texttt{*}: conta il numero di tuple nel risultato
    \end{itemize}
    \subsection{Raggruppamento}
    \begin{lstlisting}[language=SQL]
        SELECT colonna1
        FROM tabella
        GROUP BY colonna1;
    \end{lstlisting}
    Nel \texttt{GROUP BY} si possono usare solo le colonne che compaiono nella clausola \texttt{SELECT}. Raggruppa le tuple in base ai valori della colonna specificata.\\
    E' possibile specificare condizioni di ricerca su gruppi di tuple utilizzando la clausola \texttt{HAVING}:
    \begin{lstlisting}[language=SQL]
        SELECT colonna1
        FROM tabella
        GROUP BY colonna1
        HAVING condizione;
    \end{lstlisting}
    \subsection{Sotto-interrogazioni}
    \begin{lstlisting}[language=SQL]
        SELECT *
        FROM tabella
        WHERE colonna IN (SELECT colonna FROM tabella2);
    \end{lstlisting}
    Per le sotto-interrogazioni si possono usare i quantificatori \texttt{ALL} e \texttt{ANY}:
    \begin{itemize}
        \item \texttt{ANY}: restituisce vero quando la valutazione dell'operatore di confronto è vera per almeno una delle tuple restituite dalla sotto-interrogazione, restituisce falso altrimenti o se la sotto-interrogazione non restituisce tuple
        \item \texttt{ALL}: restituisce vero quando la valutazione dell'operatore di confronto è vera per tutte le tuple restituite dalla sotto-interrogazione  o se la sotto-interrogazione non restituisce tuple, restituisce falso altrimenti
    \end{itemize}
    \texttt{IN} è equivalente a \texttt{= ANY}.\\
    \texttt{NOT IN} è equivalente a \texttt{<> ALL}.\\
    \subsection{Sotto-interrogazioni correlate}
    Una sotto-interrogazione è detta \remark{correlata} se il risultato della sotto-interrogazione dipende dal valore di una colonna della query esterna. Per fare riferimento alle colonne delle tuple della query esterna si usano degli alias:
    \begin{lstlisting}[language=SQL]
        SELECT *
        FROM tabella T
        WHERE colonna IN (SELECT colonna
                          FROM tabella2
                          WHERE tabella2.colonna = T.colonna);
    \end{lstlisting}
    oppure
    \begin{lstlisting}[language=SQL]
        SELECT *
        FROM tabella AS T
        WHERE colonna IN (SELECT colonna
                          FROM tabella2
                          WHERE tabella2.colonna = T.colonna);
    \end{lstlisting}
    \subsubsection{Operatori}
    Le sotto-interrogazioni correlate sono spesso usate in combinazione con gli operatori \texttt{EXISTS} e \texttt{NOT EXISTS}:
    \begin{itemize}
        \item \texttt{EXISTS}: restituisce vero se la sotto-interrogazione restituisce almeno una tupla, falso altrimenti \begin{lstlisting}[language=SQL]
            SELECT *
            FROM tabella
            WHERE EXISTS (SELECT *
                          FROM tabella2
                          WHERE tabella2.colonna = tabella.colonna);
        \end{lstlisting}
        \item \texttt{NOT EXISTS}: restituisce vero se la sotto-interrogazione non restituisce alcuna tupla, falso altrimenti \begin{lstlisting}[language=SQL]
            SELECT *
            FROM tabella
            WHERE NOT EXISTS (SELECT *
                              FROM tabella2
                              WHERE tabella2.colonna = tabella.colonna);
        \end{lstlisting}
    \end{itemize}
    \subsection{Operatori insiemistici}
    Un'interrogazione (o sotto-interrogazione) può essere costituita da una o più sotto interrogazioni connesse dall'operatore \texttt{UNION}. Tale operatore restituisce tutte le tuple distinte restituite da almeno una delle sotto-interrogazioni a cui è applicata.
    \begin{itemize}
        \item \texttt{UNION}: restituisce l'unionde di due insiemi di tuple, elimina i duplicati
        \item \texttt{INTERSECT}: restituisce l'intersezione di due insiemi di tuple, elimina i duplicati
        \item \texttt{EXCEPT (o MINUS)}: restituisce la differenza tra due insiemi di tuple, elimina i duplicati
    \end{itemize}
    \section{Operazioni di aggiornamento}
    \subsection{Inserimento}
    \begin{lstlisting}[language=SQL]
        INSERT INTO nome_tabella
        VALUES (valore1,valore2,...);
    \end{lstlisting}
    E' possibile anche inserire una nuova tupla con i valori di alcune colonne specificate:
    \begin{lstlisting}[language=SQL]
        INSERT INTO nome_tabella (colonna1,colonna2,...)
        VALUES (valore1,valore2,...);
    \end{lstlisting}
    I valori delle colonne possono essere generati anche con una sotto-interrogazione:
    \begin{lstlisting}[language=SQL]
        INSERT INTO nome_tabella (colonna1,colonna2,...)
        sotto-interrogazione;
    \end{lstlisting}
    La clausola di proiezione della sotto-interrogazione deve includere colonne di tipo compatibile con le colonne della tupla o delle tuple da inserire. Quando usiamo una sotto-interrogazioine all'interno di un comando \texttt{INSERT} viene inserito un numero di tuple uguale alla cardinalità del risultato della sotto-interrogazione.
    \subsection{Cancellazione}
    Il comando \texttt{DELETE} permette la cancellazione di tuple da una data relazione. Le tuple da cancellare sono specificate tramite una condizione di ricerca; se non è specificata alcuna condizione di ricerca, vengono cancellate \textbf{tutte} le tuple presenti nella relazione oggetto del comando.
    \begin{lstlisting}[language=SQL]
        DELETE FROM nome_tabella
        [WHERE condizione];
    \end{lstlisting}
    \subsection{Modifica}
    Il comando \texttt{UPDATE} permette l'esecuzione di modifiche ad una o più colonne delle tuple di una relazione. Le sotto-interrogazioni possono essere usate non solo per determinare le tuple da modificare ma anche per determinare i valori da assegnare alle colonne da modificare.
    \begin{lstlisting}[language=SQL]
        UPDATE nome_tabella
        SET colonna1 = valore1, colonna2 = valore2, ...
        [WHERE condizione];
    \end{lstlisting}
    \section{Vincoli di integrità}
    SQL permette la specifica di alcuni vincoli di integrità semantica, dove con vincolo intendiamo una proprietà che un insieme di dati deve verificare. E' possibile innanzitutto disitnguere tra vincoli \remark{statici} e vincoli \remark{di transizione}. Un vincolo statico riguarda uno stato della base di dati (\textit{es. "la valutazione relativa ad un film deve essere compresa tra 0 e 5"}) mentre un vincolo di transizione mette in relazione stati diversi della base di dati (\textit{es. "non è possibile modificare la data di restituzione di un video assegnandogli una data precedente a quella memorizzata"}).
    \begin{itemize}
        \item \important{Vincoli su singola relazione}: Sono i vincoli che riguardano una singola relazione \begin{itemize}
            \item \remark{Vincoli su singola tupla}: vincoli di questo tipo coinvolgono gli attributi di una singola tupla \begin{itemize}
                \item Vincoli su singolo attributo (\textit{es. \texttt{NOT NULL}})
                \item Vincoli su attributi multipli
            \end{itemize}
            \item \remark{Vincoli su tuple multiple di una stessa relazione} \begin{itemize}
                \item Dipendenze funzionali: permettono di modellare correlazioni tra i valori di determinati attributi in tuple diverse e di esprimere che un attributo od un insieme di attributi siano chiave di una relazione
                \item Vincoli di aggregazione: impongono che una determinata funzione aggregata calcolata su un insieme di tuple verifichi una data relazione di confronto rispetto ad un valore dato
            \end{itemize}
        \end{itemize}
        \item \important{Vincoli su relazioni multiple}: sono vincoli che coinvolgono tuple di relazioni diverse. Un importante tipo di vincolo in questa classe è l'integrità referenziale
    \end{itemize}
    Quando si crea una tabella è possibile usare il comando \texttt{CHECK} per definire vincoli arbitrari su colonna o su relazione, che corrispondono a vincoli su singola tupla della classificazione precedente. Per definire un vincolo \texttt{CHECK} su una colonna si usa la seguente sintassi:
    \begin{lstlisting}[language=SQL]
        CREATE TABLE nome_tabella(
            nome_colonna tipo_colonna CHECK (condizione),
            ...
        );
    \end{lstlisting}
    Mentre per definire un vincolo \texttt{CHECK} su una relazione si usa la seguente sintassi:
    \begin{lstlisting}[language=SQL]
        CREATE TABLE nome_tabella(
            ...
            CHECK (condizione),
            ...
        );
    \end{lstlisting}
    \textit{La relazione vuota soddisfa sempre tutti i vincoli \texttt{CHECK}}.\\
    Una possibilità prevista da SQL per tutti i vincoli associati alle definizioni di relazioni è quella di assegnare un nome al vincolo premettendo alla specifica del vincolo la clausola \texttt{CONSTRAINT nome\_vincolo}. Il nome del vincolo deve essere unico rispetto ad altri nomi di vincoli definiti per la stessa relazione:
    \begin{lstlisting}[language=SQL]
        CREATE TABLE nome_tabella(
            ...
            CONSTRAINT nome_vincolo CHECK (condizione),
            ...
        );
    \end{lstlisting}
    \section{Asserzioni}
    SQL prevede il meccanismo delle asserzioni per specificare vincoli su più tuple o relazioni. Le condizioni che possono essere espresse solo tramite asserzioni sono quelle relative al numero minimo di tuple (che soddisfano una certa condizione) contenute in una tabella.
    \begin{lstlisting}[language=SQL]
        CREATE ASSERTION nome_asserzione
        CHECK (condizione);
    \end{lstlisting}
    Definire tali vincoli di integrità come asserzioni è concettualmente più corretto, ed, in generale, porta ad una verifica più efficiente.\\
    Un'asserzione può essere rimossa tramite il comando \texttt{DROP ASSERTION nome\_asserzione}.
    \section{Controllo di vincoli di integrità}\label{sec:5.9}
    SQL consente di specificare sia vincoli d'integrità con \remark{valutazione immediata}, cioè valutati dopo ogni comando di manipolazione dei dati, sia vincoli la cui \remark{valutazione è differita} al termine dell'esecuzione di una sequenza di operazioni di manipolazione dei dati, che constituiscono una \important{transazione}. Quando i vincoli sono immediatamente verificati, una violazione del vincolo causa la non esecuzione del comando che ne ha causato la violazione (eventuali modifiche parziali vengono annullate). Nel caso in cui i vincoli siano valutati alla fine della transazione, invece, la violazione del vincolo comporta l'abort della transazione. Tutte le operazioni nella transazione vengono cioè annullate, poichè non vi è modo di stabilire quale operazione ha causato la violazione del vincolo.\\
    Nella definizione di un vincolo è possibile specificare se dovrà essere sempre valutato dopo ogni singola operazione SQL (\texttt{NOT DEFERRABLE}, di default è questa), viceversa  la valutazione di un vincolo può essere differita alla fine della transazione (\texttt{DEFERRABLE}). Un vincolo \texttt{DEFERRABLE} può essere specificato con le opzioni
    \begin{itemize}
        \item \texttt{INITIALLY IMMEDIATE} (default): la verifica avviene dopo ogni istruzione SQL 
        \item \texttt{INITIALLY DEFERRED}: la verifica avviene alla fine della transazione
    \end{itemize}
    La modalità di controllo di un vincolo può essere cambiata dinamicamente:
    \begin{lstlisting}[language=SQL]
        SET CONSTRAINTS {lista vincoli | ALL} {DEFERRED | IMMEDIATE};
    \end{lstlisting} 
    Un vincolo di integrità è violato se la valutazione della condizione di controllo restituisce \texttt{FALSE}, viceversa un vincolo di integrità non è violato se la valutazione della condizione restituisce \texttt{TRUE} o \texttt{UNKNOWN}.
    \section{Dati derivati e Viste}
    \subsection{Colonne derivate}
    I valori per la colonna derivata sono calcolati ed assegnati automaticamente ogni volta che una nuova tupla è inserita nella relazione e mantenuti aggiornati in seguito ad aggiornamenti a tuple della relazione. Nel comando \texttt{CREATE TABLE} o nella clausola \texttt{ADD COLUMN} del comando \texttt{ALTER TABLE} si può specificare una colonna derivata con la seguente sintassi:
    \begin{lstlisting}[language=SQL]
        colonna_derivata [tipo_colonna] GENERATED ALWAYS AS (espressione)
    \end{lstlisting}
    \subsection{Derivazione di relazioni}
    SQL prevede la possibilità di definire una nuova relazione basandosi su relazioni già definite. A livello di schema è possibile, mediante la clausola opzionale \texttt{LIKE} del comando \texttt{CREATE TABLE}, copiare la struttura completa di una o più relazioni esistenti nella definizione di una nuova relazione.\\
    SQL permette  inoltre, mediante la clausola opzionale \texttt{AS} del comando \texttt{CREATE TABLE}, di creare una relazione con la stessa struttura di un'interrogazione. Se viene specificata la clausola \texttt{WITH DATA}, la relazione così creata è popolata con le tuple risultato della valutazione dell'interrogazione, altrimenti viene creata una relazione vuota.
    \begin{lstlisting}[language=SQL]
        CREATE TABLE nome_tabella
        [WITH DATA] AS (SELECT ...)
    \end{lstlisting}
    \section{Viste}
    In SQL è possibile definire viste alternative degli stessi dati. Una \important{vista} è una relazione \underline{virtuale} attrvaerso cui è possibile "vedere" i dati memorizzati nelle relazioni "reali" (dette di base). Il comando di definizione di una vista ha la seguente sintatti:
    \begin{lstlisting}[language=SQL]
        CREATE VIEW nome_vista [(lista colonne)]
        AS interrogazione
        [WITH [{LOCAL | CASCADED}] CHECK OPTION];
    \end{lstlisting}
    Una vista può essere cancellata tramite il comando:
    \begin{lstlisting}[language=SQL]
        DROP VIEW nome_vista {CASCADE | RESTRICT};
    \end{lstlisting}
    \subsection{Interrogazioni su viste}
    Una volta definita, una vista è parte dello schema e può essere utilizzata nelle interrogazioni come una relazione di base.
    \subsection{Aggiornamenti su viste}
    Un ulteriore aspetto da tenere in considerazione riguarda le operazioni di aggiornamento eseguite attrvaerso le viste. L'esecuzione di un'operazione di aggiornamento su una vista viene propagata alla relazione su cui la vista è definita.
    \begin{enumerate}
        \item E' possibile eseguire il comando \texttt{DELETE} sulla vista $V$ se l'interrogazione $Q$: \begin{itemize}
            \item E' un'interrogazione su una singola relazione $R$
            \item Non contiene la clausola \texttt{GROUP BY}, l'opzione \texttt{DISTINCT}, operatori insiemistici, né alcuna funzione di gruppo
            \item Eventuali sotto-interrogazioni presenti nella clausola di selezione non fanno riferimento, né mediante correlazione né elencandola esplicitamente nella clausola \texttt{FROM}, alla relazione $R$
        \end{itemize}
        \item E' possibile eseguire il comando \texttt{UPDATE} su una colonna $C$ di $V$ se $Q$: \begin{itemize}
            \item Soddisfa tutte le condizioni per il comando \texttt{DELETE}
            \item $C$ non è definita tramite un'espressione o funzione
        \end{itemize}
        \item E' possibile eseguire il comando \texttt{INSERT} su $V$ se $Q$: \begin{itemize}
            \item Soddisfa tutte le condizioni per il comando \texttt{UPDATE}
            \item Qualsiasi colonna per cui valga il vincolo \texttt{NOT NULL} è inclusa nella vista
        \end{itemize}
    \end{enumerate}
    Per assicurare quindi che le tuple inserite tramite una vista siano accettate solo se verificano la condizione dell'interrogazione di definizione della vista, si deve specificare la clausola \texttt{CHECK OPTION} nel comando di definizione della vista. L'opzione \texttt{CHECK OPTION} può essere specificata con le opzioni \texttt{LOCAL} o \texttt{CASCADED}
    \begin{itemize}
        \item \texttt{LOCAL CHECK OPTION}: solo la clausola \texttt{WHERE} della vista in cui compare l'opzione viene verificata
        \item \texttt{CASCADED CHECK OPTION} (default): le clausola \texttt{WHERE} della vista in cui compare l'opzione e di tutte le viste su cui si basa eventualmente la sua definizione vengono verificate
    \end{itemize}
    \chapter{Normalizzazione}
    La teoria della normalizzazione genera un nuovo schema equivalente al precedente ma normalizzato (senza ridondanze). Questa teoria si basa sull'analisi di determinati vincoli di integrità noti come \important{dipendenze funzionali}.
    \section{Ridondanze ed anomalie}
    Le anomalie che vogliamo eliminare tramite il processo di normalizzazione dipendono dalla presenza di dati ridondanti in una base di dati relazionale.
    \begin{itemize}
        \item \important{Anomalie di modifica}: si verificano quando si deve modificare lo stesso dato in più tuple
        \item \important{Anomalie di cancellazione}: si verificano quando si cancella una tupla che contiene informazioni che non si vogliono perdere
        \item \important{Anomalie di inserimento}: si verificano quando si vuole inserire una nuova tupla ma non si hanno tutti i dati necessari
    \end{itemize}
    L'obiettivo della teoria della normalizzazione è, quindi, quello di:
    \begin{itemize}
        \item Identificare situazioni che possono generare anomalie, partendo dall'analisi di alcuni tipi di vincoli di integrità validi per lo schema di partenza. Tali vincoli sono noti come \important{dipendenze funzionali}
        \item Identificare quali proprietà, rispetto alle dipendenze funzionali, uno schema deve soddisfare afficnhé non sia soggetto ad anomalie. Tali proprietà portano alla definizione di \important{forme normali} per gli schemi relazionali
        \item Fornire strumenti per trasformare lo schema relazionale di partenza in uno schema equivalente al precedente che soddisfi una forma normale e quindi non sia soggetto a determinati tipi di anomalie. Questo processo è noto come \important{scomposizione} e prevde la sostituzione di una relazione che presenta anomalie con un insieme di relazioni, che non presentano tale problema
    \end{itemize}
    \textbf{La normalizzazione può portare ad inefficienze nelle prestazioni, nel caso in cui le interrogazioni richiedano frequentemente di combinare i dati suddivisi in relazioni distinte}.
    \section{Dipendenze funzionali}
    Una dipendenza funzionale descrive un legame di tipo funzionale esistente tra gli attributi di una singola relazione, più formalmente:\\
    Sia $R(A_{1},\ldots,A_{n})$ uno shcme di relazione. Siano $X$ ed $Y$ sottoinsiemi di $U_{R}$. Sia $r$ un'istanta di $R(A_{1},\ldots,A_{n})$. $r$ soddisfa $X\rightarrow Y$ se, per ogni coppia di tuple $t_{1}$ e $t_{2}$ in $r$, vale la seguente condizione: se $t_{1}[X] = t_{2}[X]$, allora $t_{1}[Y] = t_{2}[Y]$.\\
    $X$ determina funzionalmente $Y$ in $R(A_{1},\ldots,A_{n})$, indicato con $X\rightarrow_{R(A_{1},\ldots,A_{n})}Y$ (o con $X \rightarrow Y$ in assenza di ambiguità) se qualunque istanza $r$ di $R(A_{1},\ldots,A_{n})$ soddisfa $X\rightarrow Y$. $X \rightarrow{R(A_{1},\ldots,A_{n})} Y$ è chiamata dipendenza funzionale su $U_{R}$.\\
    In modo compatto:
    \begin{equation*}
        \forall r\in R \text{ se } t_{1}[X]=t_{2}[X] \text{ allora } t_{1}[Y]=t_{2}[Y]
    \end{equation*}
    \textbf{Esempio:}\\
    \texttt{titolo $\rightarrow$ regista}, si legge come "uno stesso titolo non può avere registi diversi".
    \begin{itemize}
        \item \important{Dipendenze funzionali banali}: sempre valide
        \item \important{Dipendenze funzionali derivate}: sono implicate da altre dipendenze funzionali note
    \end{itemize}
    \textbf{Esempio:}
    \begin{enumerate}
        \item \texttt{titolo regista $\rightarrow$ genere}
        \item \texttt{colloc $\rightarrow$ titolo regista}
        \item \texttt{colloc $\rightarrow$ genere}
    \end{enumerate}
    La terza è una dipendenza funzionale derivate dalle prime due.
    \subsection{Chiusura di un insieme di dipendenze funzionali}
    Indicheremo con $F^{+}$ l'insieme delle dipendenze funzionali logicamente implicate da $F$ pertanto $F^{+}=\{X\rightarrow Y | F \models X \rightarrow Y\}$.
    \subsubsection{Regole di Armstrong}
    Nel seguito $D$ è un insieme di attributi:
    \begin{itemize}
        \item \important{Riflessività}: sia $Y \subseteq X \subseteq D$ allora $X \rightarrow Y$
        \item \important{Additività}: sia $Z\subseteq D$. Se $X \rightarrow Y$ allora $XZ \rightarrow YZ$
        \item \important{Transitività}: se $X \rightarrow Y$ e $Y \rightarrow Z$ allora $X \rightarrow Z$
        \item \important{Unione}: se $X \rightarrow Y$ e $X \rightarrow Z$ allora $X \rightarrow YZ$
        \item \important{Pseudotransitività}: se $X \rightarrow Y$ e $WY \rightarrow Z$ allora $WX \rightarrow Z$
        \item \important{Scomposizione}: sia $Z\subseteq Y$. Se $X \rightarrow Y$ allora $X \rightarrow Z$
    \end{itemize}
    Diciamo che $X\rightarrow Y$ è derivabile da $F$, indicato con $F \vdash X \rightarrow Y \iff F \models X\rightarrow Y$.
    \subsection{Chiusura di un insieme di attributi}
    Sia $F$ un insieme di dipendenze funzionali su un insieme di attributi $D$. Sia $X\subseteq D$. La chiusura di $X$ rispetto ad $F$, denotata con $X^{+}$, è l'insieme $\{A\in D|F\vdash X\rightarrow A\}$.
    \textbf{Esempio:}
    $D=\{colloc,titolo,regista,anno,genere,valutaz,tipo\}$
    \begin{enumerate}
        \item \texttt{titolo regista $\rightarrow$ anno}
        \item \texttt{titolo regista $\rightarrow$ genere}
        \item \texttt{titolo regista $\rightarrow$ valutaz}
        \item \texttt{colloc $\rightarrow$ titolo regista}
        \item \texttt{colloc $\rightarrow$ tipo}
    \end{enumerate}
    Prendiamo $X=\text{colloc}$, $X^{+}={\text{\{titolo,regista,tipo,anno,genere,valutaz,colloc\}}}$
    \subsection{Chiave}
    Sia $R(A_{1},\ldots,A_{n})$ uno schema di relazione, $K$ un sottoinsieme di $A_{1},\ldots,A_{n}$ e $F$ un insieme di dipendenze funzionali su $A_{1},\ldots,A_{n}$. $K$ è una chiave per $R$ se:
    \begin{enumerate}
        \item $K\rightarrow A_{1},\ldots,A_{n} \in F^{+}$
        \item Non esiste $Y\subset K$ tale che $Y\rightarrow A_{1},\ldots,A_{n} \in F^{+}$
    \end{enumerate}
    In poche parole:
    \begin{equation*}
        K^{+} = \{A_{1},\ldots,A_{n}\}
    \end{equation*}
    \textbf{Esempio:}\\
    Considerando l'esempio di prima, $X=\text{colloc}$ è chiave perchè $R\subseteq X^{+}$\\
    \textbf{Se un attributo non compare mai a destra di una dipendenza funzionale in $F$, questo attributo farà \underline{certamente} parte della chiave}.
    \section{Forme normali}
    \subsection{Forma normale di Boyce-Codd (BCNF)}
    Sia $R(A_{1},\ldots, A_{n})$ uno schema di relazione. Sia $F$ un insieme di dipendenze funzionali su $U_{R}$. $R(A_{1},\ldots, A_{n})$ è in forma normale di Boyce-Codd rispetto ad $F$ se per ogni dipendenza funzionale $X\rightarrow Y \in F$, con $Y \nsubseteq X$, allora $X$ è una chiave o super-chiave di $R$.
    \subsection{Terza forma normale (3NF)}
    \subsubsection{Attributo primo}
    Un attributo $A_{i}$ è un attributo primo di $R$ rispetto a $F$ se $A_{i}$ è contenuto in una chiave di $R$.
    \subsubsection{Terza forma normale}
    Sia $R(A_{1},\ldots, A_{n})$ uno schema di relazione. Sia $F$ un insieme di dipendenze funzionali su $U_{R}$. $R(A_{1},\ldots, A_{n})$ è in terza forma normale rispetto ad $F$ se per ogni dipendenza funzionale $X\rightarrow Y \in F$, con $Y \nsubseteq X$, allora $X$ è una chiave o super-chiave di $R$ oppure $\forall A \in Y$, $A$ è un attributo primo per $R(A_{1},\ldots, A_{n})$.
    \section{Scomposizione di schemi relazionali}
    La scomposizione di uno schema di relazione $R(A_{1},\ldots, A_{n})$ è la sua sostituzione con un insime di schemi relazionali:
    \begin{equation*}
        \Sigma = \{R_{1},\ldots,R_{k}\}
    \end{equation*}
    tali che:
    \begin{equation*}
        U_{R} = U_{R_{1}} \cup \ldots \cup U_{R_{k}}
    \end{equation*}
    Gli schemi di attributi dei vari schemi $R$ non devono essere necessariamente disgiunti, pertanto uno stesso attributo di $R$ può comparire in più schemi $R_{i}$.
    \subsection{Proprietà}
    \subsubsection{Lossless Join}
    Se una relazione viene scomposta, è importante che sia possibile riottenere esattamente la stessa relazione eseguendo il join naturale delle relazioni in cui è stata scomposta (\important{lossless join}):
    \begin{equation*}
        r = \pi_{R_{1}}(r)\bowtie \ldots \bowtie \pi_{R_{k}}(r)
    \end{equation*}
    cioè $r$ è il join naturale delle sue proiezioni sugli schemi $R_{1},\ldots,R_{k}$. \textit{Con $r$ istanza di $R$}.\\
    Una scomposizione per uno schema di relazione ha la proprietà di lossless join se soddisfa una delle seguenti implicazioni:
    \begin{itemize}
        \item $(U_{R_{1}} \cap U_{R_{2}}) \rightarrow (U_{R_{1}}-U_{R_{2}})$
        \item $(U_{R_{1}} \cap U_{R_{2}}) \rightarrow (U_{R_{2}}-U_{R_{1}})$
    \end{itemize}
    \textbf{Se gli schemi di una scomposizione sono disgiunti, la scomposizione non è  lossless join}.
    \subsubsection{Proiezione di insiemi di dipendenze funzionali}
    Sia $D$ un insieme di attributi. Sia $F$ un insieme di dipendenze funzionali su $D$. Sia $Z\subseteq D$. La proiezione di $F$ su $Z$, denotata con $\Pi_{Z}(F)$, è l'insieme $\{X\rightarrow Y|X\rightarrow Y \in F^{+}|XY\subseteq Z\}$.
    Una scomposizione preserva un insieme di dipendenze funzionali $F$ se l'unione di tutti gli insiemi di dipendenze $\Pi_{R_{i}}(F),i=1,\ldots,k$, implica logicamente tutte le dipendenze in $F$.
    \subsubsection{Scomposizione che preserva le dipendenze}
    Sia $R(A_{1},\ldots.A_{n})$ uno schema di relazione. Sia $\Sigma = \{R_{1},\ldots,R_{k}\}$ una scomposizione per $R(A_{1},\ldots.A_{n})$. Sia $F$ un insieme di dipendenze funzionali su $U_{R}$. $\Sigma$ preserva le dipendenze in $F$ se:
    \begin{equation*}
        \bigcup_{i=1,\ldots,k}\Pi_{R_{i}}(F) \models F
    \end{equation*}
    \chapter{Gestore delle strutture di memorizzazione}
    \section{Gerarchia delle memorie}
    La gerarchia può essere vista come una piramide, i dischi magnetici saranno alla base (lento, economico e capiente) mentre la \important{memoria principale} sarà in alto (veloce, costosa e di piccola capacità). Per calcolare il tempo di accesso a una memoria si può usare la formula:
    \begin{equation*}
        T_{accesso} = Latenza + \frac{\text{Dimensione dati da trasferire}}{\text{Velocità di Trasferimento}}
    \end{equation*}
    \section{Disco magnetico}
    \begin{center}
        \begin{tikzpicture}
        % Disegna il cerchio esterno
        \fill[gray] (0,0) circle [radius=4];
        \draw (0,0) circle [radius=4];
        
        % Disegna il cerchio intermedio
        \def\radius{2.5}
        \def\n{10}
        \def\angle{360/\n}
        \fill[green] (0,0) circle [radius=\radius];
        \draw (0,0) circle [radius=\radius];

        \foreach \i in {1,...,\n} {
            \ifnum \i=1
                \fill[blue!50] (0.15,0.5) -- (\i*\angle:{0.5}) -- (\i*\angle:{\radius}) arc (\i*\angle:{(\i+1)*\angle}:{\radius}) -- cycle;
            \fi
            \draw (\i*\angle:{0.5}) -- ({\angle * \i}:\radius);
        }

        % Disegna il cerchio interno
        \fill[white] (0,0) circle [radius=1];
        \draw (0,0) circle [radius=1];
        \fill[black] (0,0) circle [radius=0.5];
        \draw (0,0) circle [radius=0.5];     

        % Disegna la testina
        \fill[red] (0,1.5) -- (0.5,4) -- (-0.5,4) -- cycle;
        \end{tikzpicture}
    \end{center}
    \begin{itemize}
        \item \important{Tracce}: superficie in cui l'informazione è memorizzata (colore verde, cerchio intermedio)
        \item \important{Settore}: porzione di traccia (colore blu)
        \item \important{Cilindro}: insieme di tracce allineate verticalmente
        \item \important{Piatto}: colore grigio, cerchio esterno
        \item \important{Asse di rotazione}: asse attorno al quale ruota il piatto in senso orario (colore nero, cerchio interno)
    \end{itemize}
    Un disco è composto da uno o più piatti, per leggere e scrivere utilizza delle testine (una per ogni piatto, nel disegno di colore rosso). Le testine si muovono allo stesso tempo e non sono indipendenti l'una dall'altra.\\
    \remark{Se i dati sono memorizzati su uno stesso cilindro (anche di tracce diverse) possono essere recuperati molto più velocemente che non dati distribuiti su diversi cilindri (il movimento della testina è molto lento).}
    \begin{itemize}
        \item \important{Command Overhead}: tempo impiegato a impartire comandi al drive
        \item \important{Seek Time}: tempo impiegato dal braccio\footnote{Il braccio è quello che tiene tutte le testine allineate} a posizionarsi sulla traccia desiderata
        \item \important{Settle Time}: tempo impiegato per la stabilizzazione del braccio
        \item \important{Rotational Latency}: tempo di attesa dal primo settore da leggere
    \end{itemize}
    \subsection{Tempo di trasferimento}
    Il tempo di trasferimento è il tempo impiegato per trasferire un certo numero di byte e si riferisce alla velocità con cui si trasferiscono byte dai (sui) piatti sulla (dalla) cache del controller. Dipende dalla \important{velocità di trasferimento (o Transfer Rate $Tr$)}.\\
    Un \important{blocco (o pagina)} è una sequenza contigua di settori su una traccia, costituisce l'unità di I/O per il trasferimento dei dati tra il disco e la memoria principale.\\
    Il compito del gestore delle strutture di memorizzazione è quello di ridurre i tempi di latenza.
    \textbf{Il tempo di trasferimento di un blocco in un disco magnetico è inferiore di circa un ordine di grandezza rispetto al tempo di latenza}\footnote{Tempo di trasferimento per 4kb: 1msec, Latenza (nel caso peggiore): 10msec. Per "inferiore di un'ordine di grandezza" si intende che è 10msec/10=1msec}.
    \section{Il Database Fisico}
    \important{A livello fisico di un DB consiste in un insieme di file, ognuno dei quali viene visto come una collezione di pagine di dimensione fissa.}
    \begin{center}
        \begin{tabular}{| c | c |}
            \hline
            \textbf{LIVELLO LOGICO} & \textbf{LIVELLO FISICO}\\
            \hline
            Relazione (tabella) & File\\
            \hline
            Tupla & Record\\
            \hline
        \end{tabular}
    \end{center}
    \subsection{File}
    Un file è una sequenza di record, è detto \remark{file con record a lunghezza fissa} se tutti i record hanno la stessa dimensione in byte, altrimenti parliamo di \remark{file con record a lunghezza variabile}.
    \subsection{Record}
    Un record è costituito da un insieme di valori collegati e in generale ogni record include un header che può contenere:
    \begin{itemize}
        \item \important{Identificatore della relazione} cui il record appartiene
        \item \important{Identificatore univoco RID} del record nel DB
        \item \important{Timestamp} che indica quando il record è stato inserito o modificato per l'ultima volta
        \item \important{Lunghezza record}
    \end{itemize}
    \section{Allocazione dei file}
    \subsection{Allocazione contigua}
    \begin{itemize}
        \item I blocchi dei file sono allocati in blocchi di disco contigui quindi non si deve muovere troppo la testina
        \item Rende molto efficiente le letture dell'intero file
        \item Gli aggiornamenti sono costosi (se si ha un file pieno e si vuole aggiungere un record, devo spostare tutti i blocchi in un'altra posizione di lunghezza +1)
    \end{itemize}
    \subsection{Allocazione concatenata}
    \begin{itemize}
        \item Ogni blocco di un file contiene un puntatore al successivo blocco del file
        \item Gli aggiornamenti sono molto efficienti
        \item La lettura dell'intero file è molto lenta
        \item Utilizzo di \important{bucket} non necessariamente contigui ma vicini (possibilmente nello stesso cilindro), per gruppi di record tra loro collegati
    \end{itemize}
    \section{Organizzazione dei record nei file}
    \begin{itemize}
        \item \important{File heap}: i record vengono memorizzati in ordine di inserimento
        \item \important{File ordinato su $X$}: i record vengono memorizzati in ordine rispetto ad un campo $X$
        \item \important{File hash su $X$}: i record vengono memorizzati in ordine parziale rispetto ad un campo $X$ (vengono raggruppati in base al valore di $X$)
    \end{itemize}
    \begin{center}
        \includegraphics[scale=0.4]{Appunti Latex/Immagini/recordfile.png}
    \end{center}
    \section{Gestione del buffer}
    L’obiettivo è minimizzare il numero di accessi alla memoria non volatile, che è molto lenta. Il buffer viene gestito dal DBMS. Mantenere pi`u blocchi possibili in memoria principale in modo da evitare riletture da memoria non volatile.\\
    Il buffer è organizzato in pagine, che hanno la stessa dimensione delle pagine/blocchi su disco.
    \begin{center}
        \includegraphics[width=\textwidth]{Appunti Latex/Immagini/buffer.png}
    \end{center}
    Dopo l'esecuzione di una interrogazione, il \textbf{Buffer Manager} (BM) controlla prima nel buffer e se la pagina non è presente:
    \begin{itemize}
        \item Cerca una pagina nel buffer libera
        \item Se non è presente, cerca una pagina da sostituire
        \item Se la pagina da sostituire è stata modificata, la scrive su disco
        \item A questo punto la pagina è libera e può essere sovrascritta
    \end{itemize}
    Quando una pagina è presente nel buffer, le operazioni di lettura e scrittura possono essere effettuate su di essa.\\
    \important{Accedere alle pagine nel buffer invece che alle corrispondenti pagine su disco influenza notevolmente le prestazioni}.
    \subsection{Politiche di sostituzione}
    Il BM sceglie quale politica usare in base alle informazioni che ha.
    \begin{description}
        \item[\textbf{LRU (Least Recently Used)}]: La pagina meno recentemente usata viene sostituita. 
        \item[\textbf{MRU (Most Recently Used)}]: La pagina più recentemente usata viene sostituita. Spesso viene usata questa politica perchè il sistema sa che dovrà rileggere questo blocco ma non nell'immediato futuro.
    \end{description}
    \section{Indici}
    \subsection{Indici ad albero (o ordinati)}
    \subsubsection{Terminologia}
    \begin{itemize}
        \item \textbf{Organizzazione primaria}: l'insieme dei file dei dati
        \item \textbf{Organizzazione secondaria}: l'insieme dei file per indici ordinati
    \end{itemize}
    Le coppie $(k_{i},r_{i})$ vengono memorizzate in un file su disco (\textbf{organizzazione secondaria}), ordinate rispetto ai valori della chiave $k_{i}$. Se l'indice è molto piccolo, può essere tenuto in memoria principale. Altrimenti è necessario tenerlo su disco, quindi per rendere più efficiente l'accesso alle coppie dell'indice si usa una \textcolor{Cyan}{struttura multilivello}.\\
L'indice assume una \textbf{struttura ad albero} in cui ogni nodo dell'albero corrisponde a un blocco dati.
    \subsubsection{Requisiti}
    \begin{itemize}
        \item \important{Bilanciato}: l'indice è bilanciato rispetto ai blocchi e non ai singoli nodi (il cammino dalla radice a ogni blocco deve essere distante uguale)
        \item \important{Occupazione minima}: per evitare un sotto-utilizzo della memoria viene stabilito un limite inferiore all'utilizzazione dei blocchi
        \item \important{Efficienza di aggiornamento}: il costo delle operazioni di aggiornamento è comunque limitato
    \end{itemize}
    In un indice ad albero ogni nodo corrisponde a un blocco e il costo delle operazioni (ricerca, inserimento e cancellazione) in tali strutture è lineare nell'altezza dell'albero e logaritmico nel numero di elementi memorizzati nell'indice. Il numero massimo di elementi (coppie) memorizzabili in un nodo è $m-1$ dove $m$ dice quanti puntatori al massimo sono contenuti in un nodo ($m$ può essere maggiore di 2 quindi l'albero non è solo binario). Il numero minimo di elementi è $\lceil \frac{m}{2} \rceil -1$ ovvero l'albero è "pieno" almeno al 50\%.
    \begin{center}
        \Tree [.$B_{0}$ 
            [ .$B_{1}$\\(pl,k,pr)(pl,k,pr) $B_{3}$\\(pl,k,pr)(pl,k,pr) $B_{4}$\\(pl,k,pr)(pl,k,pr) ] 
            [ .$B_{2}$\\(pl,k,pr)(pl,k,pr) $B_{5}$\\(pl,k,pr)(pl,k,pr) $B_{6}$\\(pl,k,pr)(pl,k,pr) ]
        ] 
    \end{center}
    Nelle parentesi ci sono i puntatori ai figli. Nel caso delle foglie i puntatori punteranno all'organizzazione primaria. I nodi foglia hanno anche i puntatori ai nodi foglia successivi come una lista. I nodi puntano ai figli in base al valore della chiave ($pl$ è il puntatore sinistro, $pr$ è il puntatore destro).
    \subsubsection{Ricerca per uguaglianza}
    \includegraphics[width=\textwidth]{Appunti Latex/Immagini/ricercaindici.png}
    \begin{enumerate}
        \item La radice viene caricata nel buffer e il valore viene confrontato con il valore di ricerca ($K$) se è minore si scende a sinistra, altrimenti centrale o destra
        \item Si scende nel sottoalbero e viene controllato che il valore sia quello ricercato, se lo è scendo nel sottoalbero puntato dal numero ricercato.
        \item Ritorno al passo 1 fino a quando il nodo non punta all'organizzazione primaria. Se il valore non esiste non si accede ai file dati.
    \end{enumerate}
    \subsubsection{Ricerca per intervallo}
    \includegraphics[width=\textwidth]{Appunti Latex/Immagini/ricercaindiciintervallo.png}
Molto simile alla ricerca per uguaglianza solo che se non c'è controllo qual è la prima foglia a soddisfare la condizione (ad esempio nell'immagine il numero 88 è maggiore del numero più "vicino" quindi so che tutti i nodi a destra di quel nodo potrebbero soddisfare la condizione).
    \subsubsection{Inserimento}
    \includegraphics[width=\textwidth]{Appunti Latex/Immagini/inserimento.png}
Lo split avviene nel primo nodo pieno che si incontra. Per nodo pieno si intende che non c'è spazio per inserire un nuovo separatore.
    \subsection{Indici Clusterizzati e non Clusterizzati}
    Un indice ad albero è \important{clusterizzato} se il file dei dati è ordinato rispetto alla chiave di ricerca, in caso contrario è \important{non clusterizzato}. Le operazioni di inserimento, cancellazione e aggiornamento nel file ordinato sono facilitate dalla presenza dell'indice. \underline{Al più un indice può essere clusterizzato per tabella}. Se l'indice è su un campo chiave, che sia clusterizzato o meno, punteranno a un solo blocco. Se l'indice è su un campo non chiave, l'indice punterà a blocchi diversi.
    \subsubsection{Indici su più attributi}
    Indice la cui chiave di ricerca è costituita da più attributi, altrimenti si chiama \important{indice su singolo attributo}.
    \subsection{Indici Hash}
    Una funzione hash ottimale deve \important{distribuire uniformemente} le chiavi nello spazio negli indirizzi e \important{distribuire casualmente} le chiavi. Una funzione è detta \important{perfessa} se non vengono prodotti trabocchi. Può essere sempre definita disponendo di un'area primaria con capacità complessiva pari al numeri dei record da memorizzare. Le funzioni hash operano su \important{insiemi di chiavi intere} (se le chiavi sono alfanumeriche si può associare un id prima di applicare la trasformazione).\\
    La funzione hash è quindi definita come:
    \begin{equation*}
        h(k) = k \mod M
    \end{equation*}
    \remark{Per avere una buona distribuzione delle chiavi è opportuno che $M$ sia un numero primo oppure $\leq 20$}.\\
    L’uso di indici ad albero ha lo svantaggio di richiedere la scansione di una struttura dati, memorizzata su disco, per localizzare i dati. Questo perché le associazioni $(k_{i}, r_{i})$ vengono mantenute in forma esplicita, come record in un file Gli indici hash al contrario mantengono le associazioni $(k_{i}, r_{i})$ in modo implicito, tramite l’uso di una funzione hash, definita sul dominio della chiave di ricerca.
    \begin{center}
        \includegraphics[scale=0.5]{Appunti Latex/Immagini/indicihashgen.png}
    \end{center}
    \textit{A ogni valore della funzione hash corrisponde un indirizzo in area primaria.}\\
    \textbf{Esempio:}\\
    $I_{A}(R) \quad H(D_{A}\rightarrow\{0,\ldots,2\})$, la funzione $H$ restituisce il numero del bucket.
    \begin{itemize}
        \item $H(1)=1$
        \item $H(2)=2$
        \item $H(3)=0$
        \item $H(5)=2$
        \item $H(10)=1$
    \end{itemize}
    \begin{center}
        Bucket index: 
        \begin{tabular}{|c|c|c|}
            \hline
            0 & 1 & 2 \\
            \hline
        \end{tabular}\\
        \begin{tabular}{|c|c|}
            \hline
            A & B\\
            \hline
            1 & a \\
            2 & a \\
            3 & b \\
            5 & c \\
            10 & d \\
            3 & f \\
            \hline
        \end{tabular} $\Rightarrow$
        \begin{tabular}{|cc|}
            \hline
            \textbf{Bucket 0} & \hphantom{}\\
            3 & b\\
            3 & f \\
            \hline
            \textbf{Bucket 1} & \hphantom{}\\
            1 & a \\
            10 & d \\
            \hline
            \textbf{Bucket 2} & \hphantom{}\\
            2 & a \\
            5 & c \\
            \hline
        \end{tabular}
    \end{center}
    \subsubsection{Ricerca per uguaglianza}
    \begin{center}
        \includegraphics[scale=0.5]{Appunti Latex/Immagini/indicihashuguaglianza.png}
    \end{center}
    \textit{Non supporta la ricerca per intervallo in quanto dovrei conoscere tutti i valori dell'intervallo in quanto la funzione hash non mantiene l'ordine.}
    \subsubsection{Inserimento e Trabocchi}
    \begin{center}
        \includegraphics[scale=0.5]{Appunti Latex/Immagini/inidicihashinserimento.png}
    \end{center}
    Se il bucket è pieno, si alloca un nuovo blocco (\textit{trabocco}) dove c'è spazio chiamato \textcolor{red}{area di overflow} e se anche l'area di overflow è piena se ne crea un'altra e così via.
    \subsubsection{Ricerca}
    \begin{center}
        \includegraphics[scale=0.4]{Appunti Latex/Immagini/indicihashricercatrabocco.png}
    \end{center}
    In generale i costi di una qualsiasi operazione usando un indice hash sono:
    \begin{itemize}
        \item In assenza di overflow, il costo di accesso a indice è \important{costante}
        \item In presenza di overflow, il costo non è facilmente determinabile \begin{itemize}
            \item Quanti blocchi di overflow per il blocco acceduto?
            \item Dove sono memorizzati?
        \end{itemize}
    \end{itemize}
    \subsubsection{Indici Hash clusterizzati e non clusterizzati}
    E' \textcolor{red}{clusterizzato} se i record con chiavi simili sono memorizzati nello stesso bucket. In caso contrario è \textcolor{red}{non clusterizzato}.\\
    \textit{Finora abbiamo considerato solo gli indici clusterizzati.}
    \\\textcolor{Cyan}{Un file dei dati di tipo hash è sempre associato a un indice hash clusterizzato.}
    \\\textcolor{red}{In presenza di un indice hash \textbf{clusterizzato} l'organizzazione primaria corrisponde ai record memorizzati nell'area primaria + i record memorizzati negli overflow.}\\
    \textbf{Esempio:}
    \begin{center}
        \includegraphics[scale=0.5]{Appunti Latex/Immagini/esempioindicihashclusterizzato.png}
        \includegraphics[scale=0.5]{Appunti Latex/Immagini/esempioindicihashnonclusterizzato.png}
    \end{center}
    Gli indici non clusterizzati sono indici multilivello.\\
    Per selezioni di uguaglianza sono preferibili gli indici hash, per le selezioni di range sono preferibili gli indici ad albero.
    \chapter{Elaborazione delle interrogazioni}
    \section{Introduzione}
    La fase di ottimizzazione delle interrogazioni è una fase estremamente costosa ma la scelta di un piano di esecuzione sbagliato può avere un impatto maggiore sulle prestazioni.
    \section{Ottimizzazione Logica}
    \begin{itemize}
        \item \textbf{Input:} espressione algebrica tradotta dall'interrogazione SQL
        \item \textbf{Output:} un singolo piano di esecuzione logico ottimizzato (LQP)
    \end{itemize}
    \important{Piano di esecuzione logico}: espressione algebrica per l'interrogazione rappresentata come albero e per ottimizzare questo albero vengono utilizzate le proprietà dell'algebra relazionale.
    \begin{center}
        \includegraphics[scale=0.4]{Appunti Latex/Immagini/esempioalberologicoottimizzato.png}*
    \end{center}
    \textit{*L'esempio è incompleto ma rende l'idea}
    \subsection{Come avviene l'ottimizzazione}
    \begin{itemize}
        \item Si basa su \important{equivalenze algebriche} \begin{itemize}
            \item Due espressioni algebriche $e_{1} \text{ ed } e_{2}$ sono equivalenti se per ogni possibile base di dati in input, $e_{1}$ e $e_{2}$ restituiscono lo stesso risultato in output
        \end{itemize}
    \end{itemize}
    Queste equivalenze sono usate come \important{regole di riscrittura}, utlizzando opportune \important{euristiche} per passare da un'espressione algebrica a un'altra.
    \subsection{Esempi notevoli}
    \subsubsection{Selezione}
    \begin{equation*}
        \sigma_{P1}(\sigma_{P2}(e))\equiv \sigma_{P2}(\sigma_{P1}(e)) \equiv \sigma_{P1 \land P2}(e)
    \end{equation*}
    \subsubsection{Proiezione}
    \begin{equation*}
        \Pi_{A1,\ldots,An}(\Pi_{B1,\ldots,Bn}(e))\equiv \Pi_{A1,\ldots,An}(e)
    \end{equation*}
    Permette di gestire cascate di proiezioni e vale se $\left\{A1,\ldots,An\right\}\subseteq \left\{B1,\ldots,Bn\right\}$
    \subsubsection{Commutazione di selezione e proiezione}
    \begin{equation*}
        \Pi_{A1,\ldots,An}(\sigma_{P}(e))\equiv \sigma_{P}(\Pi_{A1,\ldots,An}(e))
    \end{equation*}
    Vale se $P$ coinvolge solo attributi $A1,\ldots,An$
    \subsubsection{Commutazione di selezione e prodotto cartesiano}
    \begin{equation*}
        \sigma_{P}(e_{1}\times e_{2}) \equiv \sigma_{P}(e_{1})\times e_{2}
    \end{equation*}
    Vale solo se $P$ coinvolge gli attributi di $e_{1}$
    \subsubsection{Commutazione di proiezione e prodotto cartesiano}
    \begin{equation*}
        \Pi_{A1,\ldots,An}(e_{1}\times e_{2})\equiv \Pi_{B1,\ldots,Bn}(e_{1}) \times \Pi_{C1,\ldots,Cn}(e_{2})
    \end{equation*}
    Se $\left\{A1,\ldots,An\right\} = \left\{B1,\ldots,Bn\right\} \cup \left\{C1,\ldots,Cn\right\}$
    \subsubsection{Selezioni, prodotto cartesiano e join}
    \begin{equation*}
        \sigma_{P}(e_{1} \times e_{2}) \equiv e_{1}\Join_{P}  e_{2}
    \end{equation*}
    \subsubsection{Prodotto cartesiano e join}
    \begin{itemize}
        \item \textbf{Commutatività} \begin{itemize}
            \item $e_{1} \Join_{F} e_{2} \equiv e_{2} \Join_{F} e_{1}$
            \item $e_{1} \Join e_{2} \equiv e_{2} \Join e_{1}$
            \item $e_{1} \times e_{2} \equiv e_{2} \times e_{1}$
        \end{itemize}
        \item \textbf{Associatività} \begin{itemize}
            \item $(e_{1} \Join_{F_{1}} e_{2})\Join_{F_{2}} e_{3} = e_{1} \Join_{F_{1}} (e_{2} \Join_{F_{2}} e_{3})$
            \item $(e_{1} \Join e_{2})\Join e_{3} = e_{1} \Join(e_{2} \Join e_{3})$
            \item $(e_{1} \times e_{2})\times e_{3} = e_{1} \times (e_{2} \times e_{3})$
        \end{itemize}
    \end{itemize}
    \subsubsection{Unione e differenza}
    \begin{itemize}
        \item \textbf{Commutatività} \begin{itemize}
            \item $e_{1} \cup e_{2} \equiv e_{2} \cup e_{1}$
            \item $\sigma_{P}(e_{1} \cup e_{2}) \equiv \sigma_{P}(e_{1}) \cup \sigma_{P}(e_{2})$
            \item $\sigma_{P}(e_{1}-e_{2}) \equiv \sigma_{P}(e_{1})-\sigma_{P}(e_{2}) \equiv \sigma_{P}(e_{1})-e_{2}$
            \item $\Pi_{A_{1},\ldots,A_{n}}(e_{1} \cup e_{2})\equiv \Pi_{A_{1},\ldots,A_{n}}(e_{1}) \cup \Pi_{A_{1},\ldots,A_{n}}(e_{2})$
        \end{itemize}
        \item \textbf{Associatività} \begin{itemize}
            \item $(e_{1} \cup e_{2})\cup e_{3} \equiv e_{1} \cup (e_{2} \cup e_{3})$
        \end{itemize}
    \end{itemize}
    \subsection{Euristiche}
    Le \important{euristiche} permettono di trasformare le equivalenze in regole di riscrittura. Va un po' a "buon senso", guarda quale delle riscritture ha l'input minore.
    \subsubsection{Euristiche fondamentali}
    \begin{itemize}
        \item \important{Anticipare il più possibile \textbf{selezioni} e \textbf{proiezioni}}
        \item Fattorizzare condizioni di selezione complesse per aumentare la possibilità di applicare le regole di riscrittura
    \end{itemize}
    \subsubsection{Euristiche principali}
    \important{Nessuna regola di riscrittura si riferisce all'ordine con cui eseguire un insieme di join (verrà ottimizzato al livello fisico)}.
    \begin{enumerate}
        \item eseguire le operazioni di selezione il prima possibile
        \item eseguire le operazioni di proiezione il prima possibile
        \item fattorizzare condizioni di selezione complesse per aumentare la possibilità di applicare le regole di riscrittura
    \end{enumerate}
    \textbf{Esempio:}\\
    Relazioni: $R(A,B,C) \quad S(D,E,F)$\\
    Query: $\Pi_{B,E}(\sigma_{A>5 \land F>6 \land C=D}(R\times S))$\\
    Ottimizzazione (\textit{i numerini sulle frecce indicano l'euristica usata}):
    \begin{description}
        \item[$\rightarrow^{1}$] $\Pi_{BE}(\sigma_{C=D}(\sigma_{A>5}(\sigma_{F>6}(R\times S))))$
        \item[$\rightarrow^{1}$] $\Pi_{BE}(\sigma_{C=D}(\sigma_{A>5}(R\times \sigma_{F>6}(S))))$
        \item[$\rightarrow^{1}$] $\Pi_{BE}(\sigma_{C=D}(\sigma_{A>5}(R)\times \sigma_{F>6}(S)))$
    \end{description}
    \section{Ottimizzazione Fisica}
    \begin{itemize}
        \item \textbf{Input}: piano di esecuzione logica ottimizzato (LQP)
        \item \textbf{Output}: piano di esecuzione fisico ottimale (PQP)
    \end{itemize}
    \important{Piano di esecuzione fisico}: algoritmo di esecuzione dell'interrogazione, rappresentato come albero, sul livello fisico.
    \subsection{Esempio}
    Ogni nodo corrisponde a un algoritmo
    \begin{center}
        \includegraphics[scale=0.6]{Appunti Latex/Immagini/esempioalberolivellofisico.png}
        \includegraphics[scale=0.6]{Appunti Latex/Immagini/esempioalberofisico.png}
    \end{center}
    \textbf{Schema fisico}
    \begin{itemize}
        \item File per $R$ ordinato rispetto ad $A$
        \item File per $S$ ordinato rispetto ad $C$
        \item Indice ordinato su $R.A:I_{A}(R)$
        \item Indice ordinato su $S.C:I_{C}(S)$
    \end{itemize}
    \subsection{Operatori Fisici}
    \important{Sono implementazioni specifiche di un operatore
    logico (ad esempio del join), basate su un certo
    algoritmo di realizzazione}.\\ Esistono diversi algoritmi di realizzazione per ogni operatore logico. Algoritmi diversi possono utilizzare diverse informazioni contenute a livello fisico.\\
    \important{La possibilità di usare un certo operatore fisico e quindi generare un certo piano fisico dipendono dallo schema fisico esistente (org primaria e indici).}\\
    Operatori fisici:
    \begin{itemize}
        \item Accesso alle relazioni di base
        \item Operazioni di relazione
        \item Operazioni di Join
    \end{itemize}
    \subsubsection{Accesso alle relazioni di base}
    Il nostro piano sarà un albero (PQP). Le foglie sono le relazioni, l'accesso alle foglie avviene tramite \important{cammini di accesso}.
    \subsubsection{Cammini di accesso}
    Descrive come accedere al file dei dati di una relazione.
    \begin{itemize}
        \item \important{Scansione sequenziale}
        \item \important{Indice più una condizione di selezione (Predicato di ricerca)}: utilizzabile solo se esiste una condizione di selezione che può essere eseguita usando l'indice
    \end{itemize}
    \textbf{Esempio:}
    \begin{verbatim}
        SELECT * FROM R WHERE R.A=5
    \end{verbatim}
    \Tree [ .$\sigma_{A=5}$ R ]
    \\Può essere implementato in due modi:
    \begin{itemize}
        \item Accesso sequenziale
        \item alla scansione sequenziale si aggiunge $(I_{A}(R),A=5)$
    \end{itemize}
    Ogni cammino di accesso diventa un nodo foglia.
    \begin{verbatim}
        SEQ SCAN R Filter (A=5)
        INDEX SCAN (I_{A}(R),A=5)
    \end{verbatim}
    \textbf{Esempio:}
    \begin{verbatim}
        SELECT * FROM R WHERE R.A <> 5
    \end{verbatim}
    Non posso usare l'indice, quindi ho solo la scansione sequenziale. Perchè io devo trovare tutte le tuple che soddisfano la condizione, ma non posso sapere a priori quali sono.
    \textbf{Esempio:}
    \begin{verbatim}
        SELECT * FROM R WHERE R.A=5 AND R.B=6
    \end{verbatim}
    \Tree [ .$\sigma_{A=5 AND B=6}$ R ]
    \begin{verbatim}
        SEQ SCAN R Filter (A=5 AND B=6)
        INDEX SCAN (I_{A}(R),A=5) Filter (B=6)
        INDEX SCAN (I_{B}(R),B=6) Filter (A=5)
    \end{verbatim}
    \remark{\textit{Dopo avere acceduto la relazione, è
    necessario filtrare (scartare) le tuple che non
    soddisfano l’altro congiunto}}.
    Per accedere una singola relazione, \remark{può anche essere scelto più di
    un cammino di accesso}, combinando poi i risultati con un ulteriore
    operatore fisico.
    \textbf{Esempio:}
    \begin{verbatim}
        SELECT * FROM R WHERE R.A=5 AND R.B=6
        INDEX SCAN (I_{A}(R),A=5)
        INDEX SCAN (I_{B}(R),B=6)
    \end{verbatim}
    E poi i risultati delle due scan vengono intersecati.
    \begin{center}
        \Tree [ .INTERSECTION [ .INDEX\_SCAN(I_{A}(R),A=5) ] [ .INDEX\_SCAN(I_{B}(R),B=6) ] ]
    \end{center}
    Con l'\textbf{OR} è simile ma si usa l'unione.
    \subsubsection{Costi}
    \begin{itemize}
        \item \textcolor{red}{Costo di accesso}: numero di pagine di blocco lette
        \item \textcolor{red}{Costo di selezione}: tipo di indice e numero di tuple che soddisfano il predicato
    \end{itemize}
    Costo totale = (costo di determinare i riferimenti ai dati che soddisfano la condizione, in organizzazione secondaria (1 per hash, $h(\log n)$ per albero)) + (costo per accedere ai
    corrispondenti blocchi dei
    dati in organizzazione
    primaria, la clusterizzazione influisce).
    \begin{itemize}
        \item Indice ordinato clusterizzato: \remark{Ogni blocco dati viene letto al più una volta}
        \item Indice ordinato non clusterizzato: \remark{Un blocco può essere acceduto più volte}
        \item Indice non ordinato clusterizzato: \remark{Un blocco può essere acceduto più volte}, i puntatori ai blocchi vengono ordinati. (Operatore BITMAP)
    \end{itemize}
    \subsubsection{Operazioni di relazione}
    \subsubsection{Selezione}
    \question{Cosa succede se eseguo una selezione su un risultato intermedio?}
    La selezione può essere implementata solo in modo sequenziale perchè \important{non è possibile utilizzare un indice su un risultato intermedio.} Se la condizione è \underline{composta}, il fattore che potrebbe rendere \textbf{falsa} tutta la condizione viene chiamato \important{fattore booleano} (\textit{esempio: $\sigma_{(A=5 \text{ OR } B=6) \text{ AND } C>10}(R)$, il fattore booleano è $R.C>10$}).
    \subsubsection{Join}
    E' un'operazione costosa: richiede $T(R)\cdot T(S)$ confronti (dove $T(R)$ e $T(S)$ sono il numero di tuple delle due relazioni). Per evitare tutti i possibili confronti:
    \begin{itemize}
        \item \important{Nested Loop Join}: Si accede ad una tupla di $R$ (outer relation) e si confronta con ogni tupla di $S$ (inner relation). L'ordine corrisponde all'ordine delle tuple della relazione esterna. Costi: $B(R) + T(R) \cdot B(S)$. \important{Conviene considerare come relazione outer la relazione più grande}.
        \item \important{Index Nested Join}: Come il nested loop join, ma si utilizza un indice su $S$ per accedere alle tuple e si usa solo se esiste l'indice. Costi: $B(R)+T(R) \cdot$costo di accesso a $S$.
        \item \important{Merge Join}: \remark{ applicabile quando le relazioni in input sono ordinate rispetto all’attributo di join}. \important{L’algoritmo sfrutta il fatto che entrambi gli input sono
        ordinati rispetto all’attributo di join}. Prima avviene l'ordinamento delle relazioni, poi si scansionano le relazioni in parallelo e si fanno i confronti tupla per tupla.
        \item \important{Hash Join}: applico la funzione hash alle tuple delle due relazioni e le metto in un bucket. Se due tuple hanno lo stesso hash, vengono messe nello stesso bucket. Si calcola il join tra i bucket. \important{Sicuramente due tuple in due bucket diversi non possono essere in join}, se sono nello stesso bucket \textbf{potrebbero} essere in join.
    \end{itemize}
    $B(\cdot)$ è il numero di blocchi letti.
    \begin{center}
        \includegraphics[scale=0.5]{Appunti Latex/Immagini/opfisici.png}
    \end{center}
    \subsubsection{Condizioni più generali}
    \begin{itemize}
        \item \important{Uguaglianza su più di un attributo}
        \item \important{Theta-join con disuguaglianza}
    \end{itemize}
    \subsection{Pipeline}
    Si può applicare solo se \remark{l’operatore fisico esegue un ciclo sulla relazione outer}. Non tutti gli algoritmi possono essere eseguiti in pipeline (ad esempio l'ordinamento).
    in questo caso, \important{il pipeline viene applicato alla relazione outer
    mentre la relazione inner, utilizzata ad ogni ciclo per i confronti,
    deve essere materializzata}
    \begin{center}
        \includegraphics[scale=0.4]{Appunti Latex/Immagini/pipeliningOpFisici.png}
    \end{center}
    \subsection{Stima del costo di un piano di esecuzione}
    Per ogni piano, la stima viene fatta a partire dalle foglie (\remark{bottom-up}). Per stimare il costo di un piano di esecuzione vengono considerati i \important{costi di accesso} e per ogni nodo dell'albero il \important{costo dell'operazione} e la \important{dimensione del risultato}. Il tutto poi sommato.\\
    Le statistiche non sono sempre aggiornate, infatti sono aggiornate periodicamente. Molti DBMS prevedono un comando per richiedere l'aggiornamento delle statistiche (\texttt{ANALYZE} in PostgreSQL).
    \subsubsection{Esempio di stima del costo: Selezione}
    \Tree [ .$\sigma_{R.C=3}$ [ .$\Join$ R S ] ]\\
    Il numero di tuple restituito è dipende da quante tuple di $R$ soddisfano la condizione (P).\\
    \important{Fattore di selettività: F(P)}, se è $<1$ è molto selettivo (poche tuple che soddisfano P) e viceversa.\\
    \question{Quante sono le tuple restituite da $\sigma_{P}(R)$?}
    $F(P)\cdot T(R)$\\
    \question{Come si stima il fattore di selettività?}
    \begin{equation*}
        F(P)=\frac{\text{Casi favorevoli}}{\text{Casi possibili}}=\frac{1}{V(C,R)}
    \end{equation*}
    \subsection{Euristica per join}
    \subsubsection{Piano Left Deep}
    \begin{equation*}
        R \Join S \Join T \Join V
    \end{equation*}
    \Tree[ .$\Join$ [ .$\Join$ [ .$\Join$ R S ] T ] V ]
    \Tree[ .$\Join$ [ .$\Join$ R S ] [ .$\Join$ T V ] ]\\
    L'albero di sinistra è Left Deep, quello di destra no.
    \subsubsection{Progettazione Fisica}
    \important{Dato un carico di lavoro, l’attività di progettazione fisico si
    preoccupare di progettare uno schema fisico, in termini di
    insieme di indici creati, che permetta di rendere il più possibile
    efficiente l’esecuzione delle operazioni contenute nel workload}. Una scelta impropria degli indici può portare a:
    \begin{itemize}
        \item inutilizzo degli indici
        \item scansioni sequenziali per uno o pochi record
        \item join multipli con tempi di esecuzione elevatissimi
        \item spreco di spazio disco1
    \end{itemize}
    \subsubsection{Approccio generale}
    Si considerano uno alla volta le interrogazioni, partendo da quelle usate più frequentemente. Per ogni interrogazione $Q$:
    \begin{itemize}
        \item si ipotizza un potenziale piano di esecuzione ottimale
        \item si individuano gli indici che permettono al sistema di prendere in considerazione il piano individuato
        \item si valuta empiricamente l'efficacia degli indici creati
        \item se gli indici non sono efficaci, cercare di comprendere la motivazione ed eventualmente rimuoverli dal livello fisico
    \end{itemize}
    Poi si valuta se gli indici identificati al passo i (per la
    query $Q_{i}$) sono compatibili con gli indici
    identificati fino al passo i-1 (per la query $Q_{i-1}$), ed
    eventualmente si apportano correttivi, \textbf{solo un indice per relazione può essere clusterizzato}.
    \chapter{Controllo dell'Accesso}
    \textit{Questo capitolo si collega alla sezione 5.9 \hyperref[sec:5.9]{Controllo di vincoli di integrità}}
    \section{Introduzione}
    Il problema è che \textbf{non tutti gli utenti possono eseguire le stesse operazioni} (\textit{es. gestore e cliente}). Lo scopo del controllo dell'accesso è quello di \textbf{limitare e controllare} le operazioni degli utenti e \textbf{prevenire} azioni che potrebbero compromettere la correttezza e la sicurezza del sistema. Le operazioni vengono catturate prima di essere eseguite.
    \section{Politiche di sicurezza}
    \begin{itemize}
        \item \remark{Regole e principi}: per la protezione delle informazioni
        \item \remark{Insieme di direttive ad alto livello}
    \end{itemize}
    \textit{Es. "le valutazioni dei film possono essere viste solo dal responsabile della videoteca"}.\\
    Tre entità principali:
    \begin{itemize}
        \item \important{Oggetti}: sono le risorse a cui vogliamo garantire protezione (le tabelle)
        \item \important{Soggetti}: sono le entità (gli utenti)
        \item \important{Privilegi}: descrivono quali operazioni possono essere eseguite dai soggetti sugli oggetti
    \end{itemize}
    \section{Controllo degli Accessi in SQL}
    \begin{itemize}
        \item \important{Sistema chiuso}: un accesso è concesso solo se è stato esplicitamente permesso
        \item \important{Amministrazione decentralizzata} (mediante \textbf{ownership}): l'utente che crea una relazione, riceve privilegi di controllo su di essa e può concedere o revocare privilegi
        \item \important{\texttt{GRANT}}: se un privilegio è concesso con grant option l'utente che lo riceve può non solo esercitare il privilegio, ma anche concederlo ad altri
        \item \important{\texttt{REVOKE}}: toglie i privilegi a uno o più utenti
    \end{itemize}
    \subsection{\texttt{GRANT}}
    L'inserimento di una nuova autorizzazione avviene tramite il comando \texttt{GRANT}:
    \begin{lstlisting}[language=SQL]
        GRANT {<lista privilegi> | ALL PRIVILEGES}
        ON <nome oggetto>
        TO {<lista utenti> | <lista ruoli> | PUBLIC}
        [WITH GRANT OPTION];
    \end{lstlisting}
    La lista dei privilegi è composta da: \texttt{SELECT}, \texttt{INSERT}, \texttt{UPDATE}, \texttt{DELETE}, ecc.\\ 
    \texttt{WITH GRANT OPTION} (opzionale) consente la delega dell'amministrazione dei privilegi.
    Alla creazione di una risorsa, il creatore riceve automaticamente tutti i privilegi su di essa quindi \textbf{i comandi di \texttt{GRANT}} corrispondenti vengono \textbf{eseguiti automaticamente} dal sistema.
    Possiamo concedere il privilegio anche su singole colonne.
    \href{https://2023.aulaweb.unige.it/pluginfile.php/352748/mod_resource/content/4/03A-controlloAccesso-23-24.pdf}{Esempi di \texttt{GRANT} (p.20)}.
    \subsection{\texttt{REVOKE}}
    La revoca di privilegi avviene tramite il comando \texttt{REVOKE}:
    \begin{lstlisting}[language=SQL]
        REVOKE [GRANT OPTION FOR] <lista privilegi>
        ON <nome oggetto>
        FROM <lista utenti>
        [CASCADE | RESTRICT];
    \end{lstlisting}
    La clausola opzionale \texttt{GRANT OPTION FOR}, se presente, revoca il privilegio di concedere il privilegio ad altri utenti. \textbf{Un utente può revocare solo i privilegi concessi da lui.}
    \section{Rappresentazione delle autorizzazioni}
    In modo astratto le informazioni contenute nei cataloghi possono essere rappresentate in astratto come un insieme di grafi (\important{grafi delle autorizzazioni}). \important{Esiste un grafo per ogni privilegio $p$ su una certa tabella}. Un grafo delle interrogazioni per il privilegio sulla tabella $R$ contiene:
    \begin{center}
        \begin{tikzpicture}[node distance={20mm}, main/.style = {draw, circle}] 
            \node[main] (1) {$u_{1}$};
            \node[main] (2) [right of = 1] {$u_{2}$}; 
            \draw[->] (1) -- node[above] {$g$} (2);
        \end{tikzpicture}
    \end{center} 
    Un nodo per ogni utente che ha il privilegio $p$ sulla tabella $R$. L'arco uscente da $u_{1}$ verso $u_{2}$ indica che $u_{1}$ ha concesso il privilegio a $u_{2}$ ed è \important{etichettato $g$ se è concesso con \texttt{GRANT OPTION}}.
    \begin{center}
        \includegraphics[scale=0.4]{Appunti Latex/Immagini/esempioautorizzazioni.png}
    \end{center}
    Un comando di \texttt{GRANT} può essere eseguito parzialmente in alcuni casi:
    \begin{center}
        \includegraphics[scale=0.4]{Appunti Latex/Immagini/esempiograntparziale.png}
    \end{center}
    Il comando \texttt{REVOKE}:
    \begin{center}
        \includegraphics[scale=0.4]{Appunti Latex/Immagini/esempiorevoke.png}
    \end{center}
    \texttt{RESTRICT}: non elimina altri nodi oltre quello designato\\
    \texttt{CASCADE}: elimina anche tutti i nodi che dipendono da quello designato, quindi se un nodo è puntato da due nodi, viene eliminato solo l'arco che parte dal nodo chiamante (però i figli vengono eliminati).
    \begin{center}
        \includegraphics[scale=0.4]{Appunti Latex/Immagini/esempiorevokecascade.png}
    \end{center}
    Se non si specifica niente, il comportamento di default è \texttt{RESTRICT}.
    \section{Ruoli}
    I ruoli sono funzioni svolte in ambito di un'organizzazione. \important{Gli utenti sono abilitati a ricoprire uno o più ruoli}. I privilegi possono essere concessi anche ai ruoli, le autorizzazioni specificate per un ruolo sono quelle necessarie per esercitare le funzioni connesse al ruolo stesso. Semplificano l'attribuzione dei privilegi ai soggetti.
    \begin{lstlisting}[language=SQL]
        CREATE ROLE <nome ruolo>;
        DROP ROLE <nome ruolo>;
        SET ROLE <nome ruolo>; -- Associazione dimanica di un ruolo all'utente della sessione attiva
    \end{lstlisting}
    Nel comando \texttt{GRANT} mettiamo
    \begin{lstlisting}[language=SQL]
        GRANT <lista ruoli>
        TO {<lista utenti> | PUBLIC}
        [WITH ADMIN OPTION]; -- Analogo a GRANT OPTION
    \end{lstlisting}
    E' possibile dare una gerarchia ai ruoli:
    \begin{lstlisting}[language=SQL]
        GRANT <ruolo_figlio> 
        TO <ruolo_padre>;
    \end{lstlisting}
    I privilegi del figlio sono acquisiti dal padre ma non viceversa.
    \\\textbf{Esempio:}
    \begin{lstlisting}[language=SQL]
        CREATE ROLE direttoreVideoteca;
        CREATE ROLE commesso;

        GRANT SELECT ON film TO commesso;
        GRANT INSERT, DELETE ON film TO direttoreVideoteca;
        GRANT commesso TO direttoreVideoteca;
    \end{lstlisting}
    Di solito prima si danno i privilegi(specifici) ai figli e poi al padre.
    \subsection{REVOKE}
    \begin{lstlisting}[language=SQL]
        REVOKE [ADMIN OPTION FOR]
        <lista ruoli>
        FROM <lista utenti>
    \end{lstlisting}
    \section{Controllo dell'accesso basato sul contenuto}
    \subsection{Autorizzazione su Viste}
    Le viste consentono di realizzare il così detto
    \important{controllo dell'accesso in base al contenuto}. Permettono di concedere anche \important{privilegi statistici} (es. una vista che computa il numero di noleggi effettuati da ogni cliente e concedere all'utente l'accesso alla vista invece che alla tabella).\\
    \question{Chi può creare una vista?}
    \remark{Gli utenti che hanno il privilegio di \texttt{SELECT} su tutte le tabelle utilizzate dalla vista.}\\
    \question{Il proprietario della vista quali privilegi può esercitare sulla vista?}
    Bisogna considerare:
    \begin{itemize}
        \item Le autorizzazioni sulle tabelle coinvolte ($P1$)
        \item \href{https://2023.aulaweb.unige.it/pluginfile.php/352757/mod_resource/content/3/LinguaggioSQLParte4DatiDerivati-23-24.pdf}{Regole per formare le autorizzazioni $P2$ (p. 26)}
    \end{itemize}
    \remark{Il proprietario ha i privilegi che ha sono l'intersezione tra $P1$ e $P2$}.
    \chapter{Transazioni}
    \section{Cosa è una transazione}
    \important{E' un'unità di elaborazione} che corrisponde a \remark{una serie di operazioni fisiche elementari} sulla base di dati a cui viene garantita un'esecuzione che soddisfa alcune buone proprietà.
    \section{Proprietà ACID}
    \begin{itemize}
        \item \important{A}tomicità: se succede qualcosa di sbagliato allora il sistema torna allo stato precedente alla transazione.
        \item \important{C}onsistenza: lo stato iniziale e finale di una transazione devono sempre soddisfare tutti i vincoli di integrita' esistenti. \textbf{Gli stati intermedi possono pero' violare la consistenza.} 
        \item \important{I}solamento: se si hanno più transazioni contemporaneamente, "non si pestano i piedi".
        \item \important{D}urabilità (persistenza): nel momento in cui la transazione è completata, le modifiche sono permanenti. 
    \end{itemize}
    Le proprietà ACID sono garantite da specifiche componenti presenti del DBMS (\important{Transaction Manager}).
    \section{Comandi SQL}
    In SQL si usano i comandi \texttt{BEGIN} e \texttt{COMMIT}:
    \begin{lstlisting}[language=SQL]
        BEGIN;
            ...
        COMMIT;
    \end{lstlisting}
    Il comando \texttt{COMMIT} restituisce \texttt{COMMIT} se è andato a buon fine, altrimenti restituisce \texttt{ROLLBACK}.\\
    Un altro modo è:
    \begin{lstlisting}[language=SQL]
        BEGIN;
            ...
        ROLLBACK;
    \end{lstlisting}
    In questo modo si annullano tutte le operazioni come se ci fosse stato un errore (anche se tutto corretto).\\
    \important{\underline{\texttt{AUTOCOMMIT}} è un'opzione che permette di eseguire ogni comando SQL come se fosse una transazione a sé stante (se \texttt{=TRUE})}
    \chapter{Riferimenti Bibliografici}
    \textit{Nota: alcuni (o tutti) i link potrebbero non essere più validi.}
    \begin{itemize}
        \item \href{https://www.dropbox.com/scl/fi/9w8y5cb2peg4oz7kvr05v/modelloRelazionale.pdf?rlkey=b8f9fo2e8tms0la9wqlkf5pno&e=1&dl=0}{Modello Relazionale}
        \item \href{https://www.dropbox.com/scl/fi/ptunok2aixlle4zso58va/concettuale.pdf?rlkey=e0pvma78pnq2vdkisp81tcsux&e=1&dl=0}{Progettazione concettuale}
        \item \href{https://www.dropbox.com/scl/fi/jjvvpol4p4vodi24jjr1u/progettazionelogica.pdf?rlkey=ggi2mchpt7xrnumhvprdi420x&e=1&dl=0}{Progettazione logica}
        \item \href{https://www.dropbox.com/scl/fi/wjtpva027ju0fei216kls/sqlDDL.pdf?rlkey=5a0k6g99sq8zvx4iea4df6c5l&e=1&dl=0}{SQL DDL}
        \item SQL Query \begin{itemize}
            \item \href{https://www.dropbox.com/scl/fi/ly22527v36sp153e38c1g/sqlQuery1.pdf?rlkey=08pme9f9kornu6m0utbvejeyl&e=1&dl=0}{Prima parte}
            \item \href{https://www.dropbox.com/scl/fi/eczn4be6s050tzxrtqbym/sqlQuery2.pdf?rlkey=pf45n3a0da1m32ub8yquflb5v&e=1&dl=0}{Seconda parte}
            \item \href{https://www.dropbox.com/scl/fi/q6gl4sn3egmqeejs5z74l/sqlQuery3.pdf?rlkey=yg82xztwpktkhrg0u59i5jm8d&e=1&dl=0}{Terza parte}
        \end{itemize}
        \item Algebra Relazionale \begin{itemize}
            \item \href{https://www.dropbox.com/scl/fi/c1grvxcutg64g3ud33925/algebraRelazionale1.pdf?rlkey=uhzbmw6t125hw6khkd0uhv4uh&e=1&dl=0}{Prima parte}
            \item \href{https://www.dropbox.com/scl/fi/g8c7xiqw56bs1pbcepcx3/algebraRelazionale2.pdf?rlkey=i9pznnyv1vzkeyje7ujjiy3cg&e=1&dl=0}{Seconda parte}
        \end{itemize}
        \item \href{https://2023.aulaweb.unige.it/pluginfile.php/352551/mod_book/chapter/829/sqlModifiche.pdf}{Modifiche in SQL}
        \item \href{https://2023.aulaweb.unige.it/pluginfile.php/352551/mod_book/chapter/829/sqllVincoli.pdf}{Vincoli di Integrità in SQL}
        \item \href{https://www.dropbox.com/scl/fi/cpqszf14jy3ng39nrkt64/sqllViste.pdf?rlkey=8zxyihsdlmvtcbb67dq762gqm&e=1&dl=0}{Dati derivati e viste}
        \item \href{https://2023.aulaweb.unige.it/pluginfile.php/352551/mod_book/chapter/835/normalizzazione.pdf}{Normalizzazione}
        \item \href{https://www.dropbox.com/scl/fi/68ovdsvcp11ojj2izgd6o/gestore%20delle%20strutture%20di%20memorizzazione%20e%20di%20accesso.pdf?rlkey=49iws799mhi21arnjyos2c51r&e=1&dl=0}{Strutture di memorizzazione e di accesso}
        \item \href{https://www.dropbox.com/scl/fi/1s8pjkfvv3qhw6n9vxgv6/elab-interrogazioni.pdf?rlkey=dnfz86cnhyz94hvxs4jmx23gz&e=1&dl=0}{Elaborazione di interrogazioni}
        \item \href{https://www.dropbox.com/scl/fi/wt3igo4wa8hfvoywlv8tm/controlloAccesso.pdf?rlkey=j4pfjg3mu7xundkmi6sbg3xvw&e=1&dl=0}{Controllo dell'Accesso}
        \item \href{https://www.dropbox.com/scl/fi/aqtxqxwpirdfxg9fpxtbs/transazioni.pdf?rlkey=xmjnie9k0ucfpz5xdhqbohyyi&e=1&dl=0}{Transazioni}
    \end{itemize}
    \end{document}